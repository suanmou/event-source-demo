import java.util.concurrent.*;

/**
 * 全局线程池管理器：统一管理连接池、发送池，避免线程爆炸
 */
class ThreadPoolManager {
    // 连接池：负责分批建立会话连接（限流），核心线程数=50（可调整）
    private final ScheduledExecutorService connectPool = new ScheduledThreadPoolExecutor(
            50,
            new ThreadFactory() {
                private final AtomicInteger seq = new AtomicInteger(0);
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r, "connect-pool-" + seq.getAndIncrement());
                    t.setDaemon(true);
                    t.setPriority(Thread.NORM_PRIORITY);
                    return t;
                }
            }
    );

    // 发送池：负责所有会话的消息发送，核心线程数=500（支撑5000会话，可调整）
    private final ScheduledExecutorService sendPool = new ScheduledThreadPoolExecutor(
            500,
            new ThreadFactory() {
                private final AtomicInteger seq = new AtomicInteger(0);
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r, "send-pool-" + seq.getAndIncrement());
                    t.setDaemon(true);
                    t.setPriority(Thread.MAX_PRIORITY); // 发送任务优先
                    return t;
                }
            }
    );

    // 单例模式（避免重复创建线程池）
    private static volatile ThreadPoolManager instance;
    private ThreadPoolManager() {}
    public static ThreadPoolManager getInstance() {
        if (instance == null) {
            synchronized (ThreadPoolManager.class) {
                if (instance == null) {
                    instance = new ThreadPoolManager();
                }
            }
        }
        return instance;
    }

    // 提交连接任务（分批建立会话）
    public ScheduledFuture<?> submitConnectTask(Runnable task, long delay, TimeUnit unit) {
        return connectPool.schedule(task, delay, unit);
    }

    // 提交发送任务（定时发送消息）
    public ScheduledFuture<?> submitSendTask(Runnable task, long initialDelay, long period, TimeUnit unit) {
        return sendPool.scheduleAtFixedRate(task, initialDelay, period, unit);
    }

    // 关闭所有线程池
    public void shutdownAll() {
        connectPool.shutdown();
        sendPool.shutdown();
        try {
            if (!connectPool.awaitTermination(1, TimeUnit.MINUTES)) {
                connectPool.shutdownNow();
            }
            if (!sendPool.awaitTermination(1, TimeUnit.MINUTES)) {
                sendPool.shutdownNow();
            }
        } catch (InterruptedException e) {
            connectPool.shutdownNow();
            sendPool.shutdownNow();
        }
    }
}


class InitiatorPool {
    private final List<SocketInitiator> initiatorList = new CopyOnWriteArrayList<>();
    private final List<SessionID> allSessionIDs = new CopyOnWriteArrayList<>();
    private final ConcurrentHashMap<String, ConnectionStatus> connStatusMap = new ConcurrentHashMap<>();
    private final AtomicInteger connectedCount = new AtomicInteger(0);
    private final int totalSessions;
    private final int sessionsPerInitiator = 10; // 每个Initiator管理10个会话（可调整）
    private final int connectionsPerSecond = 50; // 每秒建立50个连接（限流）

    enum ConnectionStatus { INIT, CONNECTING, CONNECTED, FAILED }

    public InitiatorPool(int totalSessions) {
        this.totalSessions = totalSessions;
        // 初始化所有会话状态
        for (int i = 0; i < totalSessions; i++) {
            String sessionKey = "BENCH-CLIENT-" + i;
            connStatusMap.put(sessionKey, ConnectionStatus.INIT);
        }
    }

    /**
     * 创建共享Initiator（每个管理10个会话）
     */
    public void createSharedInitiators(FixBenchmarkApplication application, String configTemplatePath) throws Exception {
        int initiatorCount = (totalSessions + sessionsPerInitiator - 1) / sessionsPerInitiator; // 向上取整
        System.out.printf("创建%d个共享Initiator，每个管理%d个会话%n", initiatorCount, sessionsPerInitiator);

        for (int initiatorIdx = 0; initiatorIdx < initiatorCount; initiatorIdx++) {
            // 为当前Initiator分配会话（如第0个Initiator管理0-9号会话，第1个管理10-19号等）
            int startSessionIdx = initiatorIdx * sessionsPerInitiator;
            int endSessionIdx = Math.min((initiatorIdx + 1) * sessionsPerInitiator, totalSessions);

            // 创建包含当前批次会话的配置
            SessionSettings batchSettings = createBatchSessionSettings(configTemplatePath, startSessionIdx, endSessionIdx);
            // 创建共享Initiator（管理多个会话）
            SocketInitiator initiator = new SocketInitiator(
                    application,
                    new MemoryStoreFactory(),
                    batchSettings,
                    new NullLogFactory()
            );
            // 优化Initiator线程池（每个Initiator用2个线程）
            ((ScheduledThreadPoolExecutor) initiator.getExecutor()).setCorePoolSize(2);
            ((ScheduledThreadPoolExecutor) initiator.getExecutor()).setMaximumPoolSize(4);

            initiatorList.add(initiator);
            // 记录所有会话ID
            allSessionIDs.addAll(batchSettings.getSessions());
        }
        System.out.printf("成功创建%d个Initiator，管理%d个会话%n", initiatorList.size(), allSessionIDs.size());
    }

    /**
     * 线程池分批启动连接（限流，避免连接风暴）
     */
    public void startWithRateLimit() {
        ThreadPoolManager threadPool = ThreadPoolManager.getInstance();
        AtomicInteger sessionIdx = new AtomicInteger(0);

        // 每秒启动connectionsPerSecond个会话连接
        threadPool.submitSendTask(() -> {
            int currentIdx = sessionIdx.getAndIncrement();
            if (currentIdx >= totalSessions) {
                return;
            }

            String sessionKey = "BENCH-CLIENT-" + currentIdx;
            if (connStatusMap.get(sessionKey) != ConnectionStatus.INIT) {
                return;
            }

            // 查找当前会话所属的Initiator并启动
            try {
                connStatusMap.put(sessionKey, ConnectionStatus.CONNECTING);
                // 找到会话对应的Initiator（通过SessionID匹配）
                SessionID targetSessionID = allSessionIDs.stream()
                        .filter(sid -> sid.getSenderCompID().equals(sessionKey))
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("会话不存在：" + sessionKey));

                SocketInitiator initiator = findInitiatorBySessionID(targetSessionID);
                if (!initiator.isRunning()) {
                    initiator.start();
                }

                System.out.printf("启动会话[%d]，SessionID=%s，当前连接中：%d个%n",
                        currentIdx, targetSessionID, connectedCount.get() + 1);
            } catch (Exception e) {
                connStatusMap.put(sessionKey, ConnectionStatus.FAILED);
                System.err.printf("会话[%d]启动失败：%s%n", currentIdx, e.getMessage());
            }
        }, 0, 1000 / connectionsPerSecond, TimeUnit.MILLISECONDS);
    }

    // 查找会话所属的Initiator
    private SocketInitiator findInitiatorBySessionID(SessionID sessionID) {
        for (SocketInitiator initiator : initiatorList) {
            if (initiator.getSessions().contains(sessionID)) {
                return initiator;
            }
        }
        throw new RuntimeException("未找到会话对应的Initiator：" + sessionID);
    }

    // 批量创建会话配置（一个Initiator管理多个会话）
    private SessionSettings createBatchSessionSettings(String configTemplatePath, int startIdx, int endIdx) throws Exception {
        SessionSettings templateSettings = new SessionSettings(new FileInputStream(configTemplatePath));
        SessionID templateSessionID = templateSettings.getSessions().iterator().next();
        Properties templateProps = templateSettings.getSessionProperties(templateSessionID);
        SessionSettings batchSettings = new SessionSettings();

        // 复制全局配置
        templateSettings.getGlobalSettings().forEach((key, value) -> batchSettings.setGlobalSetting(key, value));

        // 添加当前批次的所有会话
        for (int i = startIdx; i < endIdx; i++) {
            String senderCompID = "BENCH-CLIENT-" + i;
            SessionID newSessionID = new SessionID(
                    templateSessionID.getBeginString(),
                    senderCompID,
                    templateSessionID.getTargetCompID()
            );
            Properties sessionProps = new Properties(templateProps);
            sessionProps.setProperty("SenderCompID", senderCompID);
            batchSettings.set(newSessionID, sessionProps);
        }

        return batchSettings;
    }

    // 标记会话连接成功
    public void markConnected(SessionID sessionID) {
        connStatusMap.put(sessionID.toString(), ConnectionStatus.CONNECTED);
        connectedCount.incrementAndGet();
    }

    // 等待所有会话连接完成
    public void waitForAllConnected(long timeoutMinutes) throws InterruptedException {
        long timeoutMillis = timeoutMinutes * 60 * 1000;
        long start = System.currentTimeMillis();

        while (System.currentTimeMillis() - start < timeoutMillis) {
            int connected = connectedCount.get();
            int failed = (int) connStatusMap.values().stream().filter(s -> s == ConnectionStatus.FAILED).count();
            int remaining = totalSessions - connected - failed;

            System.out.printf("连接进度：成功%d/%d，失败%d/%d，剩余%d/%d%n",
                    connected, totalSessions, failed, totalSessions, remaining, totalSessions);

            if (connected + failed >= totalSessions) {
                break;
            }

            TimeUnit.SECONDS.sleep(2);
        }
    }

    // 关闭所有Initiator
    public void shutdownAll() {
        for (SocketInitiator initiator : initiatorList) {
            try {
                if (initiator.isRunning()) {
                    initiator.stop();
                    initiator.getExecutor().shutdown();
                    initiator.getExecutor().awaitTermination(10, TimeUnit.SECONDS);
                }
            } catch (Exception e) {
                System.err.println("关闭Initiator失败：" + e.getMessage());
            }
        }
    }

    // Getter
    public int getConnectedCount() { return connectedCount.get(); }
    public int getTotalSessions() { return totalSessions; }
}


static class FixBenchmarkApplication implements Application {
    private final MetricsCollector metrics;
    private final int tpsPerSession;
    private final long durationMinutes;
    private final long timeoutMillis;
    private final InitiatorPool initiatorPool;
    private final boolean waitForAllReady;
    private final int sendDelaySeconds;
    private final List<SessionID> readySessions = new CopyOnWriteArrayList<>();
    private final AtomicBoolean sendTriggered = new AtomicBoolean(false);
    private final ThreadPoolManager threadPool = ThreadPoolManager.getInstance();

    public FixBenchmarkApplication(MetricsCollector metrics, int tpsPerSession, long durationMinutes,
                                  long timeoutMillis, InitiatorPool initiatorPool,
                                  boolean waitForAllReady, int sendDelaySeconds) {
        this.metrics = metrics;
        this.tpsPerSession = tpsPerSession;
        this.durationMinutes = durationMinutes;
        this.timeoutMillis = timeoutMillis;
        this.initiatorPool = initiatorPool;
        this.waitForAllReady = waitForAllReady;
        this.sendDelaySeconds = sendDelaySeconds;

        // 全局超时检查（复用线程池）
        threadPool.submitSendTask(() -> metrics.checkTimeouts(timeoutMillis), 0, 1, TimeUnit.SECONDS);
    }

    @Override
    public void onCreate(SessionID sessionID) {
        String sessionKey = sessionID.toString();
        metrics.initSession(sessionKey);
    }

    @Override
    public void onLogon(SessionID sessionID) {
        String sessionKey = sessionID.toString();
        metrics.markFirstLoginSuccess(sessionKey);
        initiatorPool.markConnected(sessionID);
        readySessions.add(sessionID);
        System.out.printf("Session[%s]登录成功，就绪数：%d/%d%n",
                sessionKey, readySessions.size(), initiatorPool.getTotalSessions());

        if (!waitForAllReady && sendTriggered.compareAndSet(false, true)) {
            startAllSendTasks();
        }
    }

    @Override
    public void onLogout(SessionID sessionID) {
        readySessions.remove(sessionID);
        System.out.printf("Session[%s]断开连接%n", sessionID);
    }

    // 全局统一发送（复用发送线程池）
    public void triggerGlobalSend() {
        synchronized (this) {
            if (sendTriggered.get()) return;

            int totalReady = readySessions.size();
            System.out.printf("===== 触发全局发送：就绪会话%d个，延迟%d秒 =====", totalReady, sendDelaySeconds);

            if (sendDelaySeconds > 0) {
                try {
                    TimeUnit.SECONDS.sleep(sendDelaySeconds);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }

            startAllSendTasks();
            sendTriggered.set(true);
            System.out.println("===== 所有就绪会话开始发送 =====");
        }
    }

    // 启动所有会话的发送任务（复用线程池）
    private void startAllSendTasks() {
        for (SessionID sessionID : readySessions) {
            startSendTask(sessionID);
        }
    }

    // 发送任务（复用全局发送线程池）
    private void startSendTask(SessionID sessionID) {
        String sessionKey = sessionID.toString();
        AtomicLong seq = new AtomicLong(0);
        long intervalMs = tpsPerSession > 0 ? 1000 / tpsPerSession : 0;

        Runnable sendTask = () -> {
            try {
                Session session = Session.lookupSession(sessionID);
                if (session == null || !session.isLoggedOn()) {
                    String testReqID = "TEST-" + sessionKey + "-" + seq.getAndIncrement();
                    metrics.trackSendFailed(sessionKey, testReqID, ErrorReason.SESSION_NOT_LOGGED_IN);
                    return;
                }

                String testReqID = "TEST-" + sessionKey + "-" +
                        UUID.randomUUID().toString().substring(0, 8) + "-" + seq.getAndIncrement();
                TestRequest request = new TestRequest();
                request.set(new TestReqID(testReqID));
                metrics.trackSent(sessionKey, new TestRequestTrack(testReqID, Instant.now()));

                boolean sent = Session.sendToTarget(request, sessionID);
                if (!sent) {
                    metrics.trackSendFailed(sessionKey, testReqID, ErrorReason.SEND_EXCEPTION);
                }
            } catch (Exception e) {
                String testReqID = "TEST-" + sessionKey + "-" + seq.getAndIncrement();
                metrics.trackSendFailed(sessionKey, testReqID, ErrorReason.SEND_EXCEPTION);
            }
        };

        // 提交到全局发送线程池
        threadPool.submitSendTask(sendTask, 0, intervalMs, TimeUnit.MILLISECONDS);

        // 测试结束后取消任务（通过线程池shutdown统一处理）
        threadPool.submitSendTask(() -> {
            System.out.printf("Session[%s]发送任务结束%n", sessionKey);
        }, durationMinutes, 1, TimeUnit.MINUTES);
    }

    // 其他接口实现（不变）
    @Override public void toAdmin(Message message, SessionID sessionID) {}
    @Override public void fromAdmin(Message message, SessionID sessionID) throws FieldNotFound, UnsupportedMessageType, IncorrectTagValue {
        if (message instanceof LogonReject) {
            LogonReject reject = (LogonReject) message;
            String reason = reject.isSetField(quickfix.field.Text.FIELD) ? reject.getText().getValue() : "未知原因";
            System.err.printf("Session[%s]登录被拒: %s%n", sessionID, reason);
            metrics.trackSendFailed(sessionID.toString(), "LOGON-REJECT", ErrorReason.LOGON_REJECT);
        }
    }
    @Override public void toApp(Message message, SessionID sessionID) throws DoNotSend {}
    @Override public void fromApp(Message message, SessionID sessionID) throws FieldNotFound, UnsupportedMessageType, IncorrectTagValue {
        if (message instanceof Heartbeat && message.isSetField(TestReqID.FIELD)) {
            Heartbeat heartbeat = (Heartbeat) message;
            String testReqID = heartbeat.getTestReqID().getValue();
            metrics.trackReceived(sessionID.toString(), testReqID, Instant.now());
        }
    }
}



public static void main(String[] args) throws Exception {
    // 压测参数（5000会话）
    int sessionCount = 5000;         // 目标会话数（5000）
    int tpsPerSession = 5;           // 单会话TPS=5（总TPS=5000×5=25000）
    long durationMinutes = 10;       // 测试持续时间
    long timeoutMillis = 5000;       // 消息超时时间
    boolean waitForAllReady = true;  // 等待所有会话就绪后发送
    int sendDelaySeconds = 15;       // 就绪后延迟15秒发送
    String configPath = "fix-client-template.cfg";

    // 1. 初始化组件
    InitiatorPool initiatorPool = new InitiatorPool(sessionCount);
    MetricsCollector metrics = new MetricsCollector();
    FixBenchmarkApplication application = new FixBenchmarkApplication(
            metrics, tpsPerSession, durationMinutes, timeoutMillis,
            initiatorPool, waitForAllReady, sendDelaySeconds
    );

    // 2. 创建共享Initiator（每个管理10个会话，共500个Initiator）
    initiatorPool.createSharedInitiators(application, configPath);

    // 3. 限流启动连接（每秒50个，5000个约100秒启动完成）
    System.out.println("开始启动5000个会话连接...");
    initiatorPool.startWithRateLimit();

    // 4. 等待所有会话连接就绪（最多30分钟）
    initiatorPool.waitForAllConnected(30);

    // 5. 输出连接结果
    int connectedCount = initiatorPool.getConnectedCount();
    System.out.printf("%n连接结果：成功%d个，失败%d个，成功率：%.2f%%%n",
            connectedCount, sessionCount - connectedCount, (double) connectedCount / sessionCount * 100);

    // 6. 触发全局统一发送
    if (waitForAllReady) {
        application.triggerGlobalSend();
    }

    // 7. 等待测试完成
    System.out.printf("压测中... 总TPS目标：%d%n", sessionCount * tpsPerSession);
    TimeUnit.MINUTES.sleep(durationMinutes);

    // 8. 停止压测，输出报告
    initiatorPool.shutdownAll();
    ThreadPoolManager.getInstance().shutdownAll();
    System.out.println(metrics.generateSummaryReport());
    System.out.println(metrics.generatePerSessionReport());
}