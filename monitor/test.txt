import socket
import struct
import time
import sys
import argparse
from collections import defaultdict

# FIXåè®®å¸¸é‡
FIX_SOH = b'\x01'  # FIXæ¶ˆæ¯å­—æ®µåˆ†éš”ç¬¦
FIX_LOGON_MSG_TYPE = b'A'  # ç™»å½•æ¶ˆæ¯ç±»å‹
FIX_LOGOUT_MSG_TYPE = b'5'  # ç™»å‡ºæ¶ˆæ¯ç±»å‹
FIX_MSGTYPE_TAG = b'35='  # MsgTypeæ ‡ç­¾ï¼ˆ35=Aè¡¨ç¤ºç™»å½•ï¼‰

# é»˜è®¤é…ç½®
DEFAULT_FIX_SERVERS = []
DEFAULT_MONITOR_INTERVAL = 60  # ç»Ÿè®¡è¾“å‡ºé—´éš”ï¼ˆç§’ï¼‰
DEFAULT_TIMEOUT = 300  # è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼Œæ— æ´»åŠ¨åˆ™ç§»é™¤ï¼‰
DEFAULT_LOG_OUTPUT = "stdout"


def parse_args():
    """è§£æå‘½ä»¤è¡Œå‚æ•°"""
    parser = argparse.ArgumentParser(description="FIXå·²ç™»å½•è¿æ¥ç›‘æ§å·¥å…·ï¼ˆæ— ç¬¬ä¸‰æ–¹ä¾èµ–ï¼‰")
    parser.add_argument(
        "-s", "--servers",
        type=str,
        nargs="+",
        required=True,
        help="ä¸‹æ¸¸FIXæœåŠ¡å™¨ï¼ˆå¿…å¡«ï¼‰ï¼Œæ ¼å¼ï¼šIP:ç«¯å£ï¼Œå¤šä¸ªç”¨ç©ºæ ¼åˆ†éš”ï¼Œä¾‹ï¼š192.168.1.100:9876"
    )
    parser.add_argument(
        "-i", "--interval",
        type=int,
        default=DEFAULT_MONITOR_INTERVAL,
        help=f"ç»Ÿè®¡è¾“å‡ºé—´éš”ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_MONITOR_INTERVAL}"
    )
    parser.add_argument(
        "-t", "--timeout",
        type=int,
        default=DEFAULT_TIMEOUT,
        help=f"è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼Œæ— æ´»åŠ¨åˆ™ç§»é™¤ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_TIMEOUT}"
    )
    parser.add_argument(
        "-l", "--log",
        type=str,
        default=DEFAULT_LOG_OUTPUT,
        help=f"æ—¥å¿—è¾“å‡ºæ–¹å¼ï¼Œstdoutï¼ˆæ§åˆ¶å°ï¼‰æˆ–æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ï¼š{DEFAULT_LOG_OUTPUT}"
    )
    return parser.parse_args()


def validate_servers(servers_str):
    """éªŒè¯å¹¶è§£ææœåŠ¡å™¨åˆ—è¡¨ï¼ˆIP:ç«¯å£ï¼‰"""
    valid_servers = []
    for s in servers_str:
        if ":" not in s:
            print(f"âŒ æ— æ•ˆæœåŠ¡å™¨æ ¼å¼ï¼š{s}ï¼Œæ­£ç¡®æ ¼å¼ï¼šIP:ç«¯å£", file=sys.stderr)
            sys.exit(1)
        ip, port_str = s.split(":", 1)
        try:
            port = int(port_str)
            if not (1 <= port <= 65535):
                raise ValueError
            valid_servers.append((ip, port))
        except ValueError:
            print(f"âŒ æ— æ•ˆç«¯å£ï¼š{port_str}ï¼Œéœ€ä¸º1-65535çš„æ•´æ•°", file=sys.stderr)
            sys.exit(1)
    return valid_servers


def ip_to_bytes(ip):
    """IPå­—ç¬¦ä¸²è½¬4å­—èŠ‚ï¼ˆç”¨äºæ•°æ®åŒ…è§£æï¼‰"""
    return socket.inet_aton(ip)


def bytes_to_ip(bytes_data):
    """4å­—èŠ‚è½¬IPå­—ç¬¦ä¸²"""
    return socket.inet_ntoa(bytes_data)


def parse_tcp_packet(data):
    """è§£æTCPæ•°æ®åŒ…ï¼Œæå–æºIPã€æºç«¯å£ã€ç›®æ ‡IPã€ç›®æ ‡ç«¯å£ã€TCPæ•°æ®"""
    try:
        # è§£æIPå¤´ï¼ˆ20å­—èŠ‚å›ºå®šéƒ¨åˆ†ï¼‰
        ip_header = data[:20]
        iph = struct.unpack('!BBHHHBBH4s4s', ip_header)
        protocol = iph[6]  # åè®®ç±»å‹ï¼ˆ6=TCPï¼‰
        if protocol != 6:
            return None  # éTCPæ•°æ®åŒ…ï¼Œè·³è¿‡
        
        src_ip = bytes_to_ip(iph[8])
        dst_ip = bytes_to_ip(iph[9])
        ip_header_len = (iph[0] & 0x0F) * 4  # IPå¤´é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰
        
        # è§£æTCPå¤´ï¼ˆ20å­—èŠ‚å›ºå®šéƒ¨åˆ†ï¼‰
        tcp_header = data[ip_header_len:ip_header_len+20]
        tcph = struct.unpack('!HHLLBBHHH', tcp_header)
        src_port = tcph[0]
        dst_port = tcph[1]
        tcp_header_len = ((tcph[4] & 0xF0) >> 4) * 4  # TCPå¤´é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰
        
        # æå–TCPè´Ÿè½½æ•°æ®ï¼ˆFIXæ¶ˆæ¯å†…å®¹ï¼‰
        tcp_data = data[ip_header_len + tcp_header_len:]
        if not tcp_data:
            return None  # æ— æ•°æ®è´Ÿè½½ï¼Œè·³è¿‡
        
        return {
            'src_ip': src_ip,
            'src_port': src_port,
            'dst_ip': dst_ip,
            'dst_port': dst_port,
            'data': tcp_data
        }
    except Exception as e:
        # å¿½ç•¥è§£æå¤±è´¥çš„æ•°æ®åŒ…ï¼ˆå¦‚åˆ†ç‰‡ã€å¼‚å¸¸æ ¼å¼ï¼‰
        return None


def parse_fix_msg_type(tcp_data):
    """ä»TCPæ•°æ®ä¸­æå–FIXæ¶ˆæ¯çš„MsgTypeï¼ˆä»…å¤„ç†å®Œæ•´/éƒ¨åˆ†FIXæ¶ˆæ¯ï¼‰"""
    # FIXæ¶ˆæ¯ä»¥SOHåˆ†éš”ï¼Œå…ˆæŒ‰SOHæ‹†åˆ†å­—æ®µ
    fields = tcp_data.split(FIX_SOH)
    for field in fields:
        if field.startswith(FIX_MSGTYPE_TAG):
            # æå–MsgTypeï¼ˆå¦‚b'35=A' â†’ b'A'ï¼‰
            msg_type = field[len(FIX_MSGTYPE_TAG):]
            if msg_type in [FIX_LOGON_MSG_TYPE, FIX_LOGOUT_MSG_TYPE]:
                return msg_type.decode('ascii', errors='ignore')
    return None


def init_raw_socket(os_type):
    """åˆå§‹åŒ–åŸå§‹å¥—æ¥å­—ï¼ˆé€‚é…Linux/Windowsï¼‰"""
    try:
        if os_type == "linux":
            # Linuxï¼šPF_PACKETåè®®æ—ï¼ŒæŠ“å–æ‰€æœ‰ç½‘å¡çš„TCPæµé‡
            sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))
        elif os_type == "windows":
            # Windowsï¼šSOCK_RAW + IPPROTO_TCPï¼Œéœ€è¦ç®¡ç†å‘˜æƒé™
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            # å¯ç”¨æ··æ‚æ¨¡å¼ï¼ˆæŠ“å–æ‰€æœ‰æµé‡ï¼‰
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
        else:
            raise NotImplementedError(f"âŒ ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿï¼š{os_type}")
        return sock
    except PermissionError:
        print("âŒ æƒé™ä¸è¶³ï¼è¯·ä»¥ç®¡ç†å‘˜ï¼ˆWindowsï¼‰æˆ–rootï¼ˆLinuxï¼‰èº«ä»½è¿è¡Œç¨‹åº", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"âŒ åˆå§‹åŒ–æŠ“åŒ… socket å¤±è´¥ï¼š{str(e)}", file=sys.stderr)
        sys.exit(1)


def get_os_type():
    """è·å–æ“ä½œç³»ç»Ÿç±»å‹ï¼ˆlinux/windowsï¼‰"""
    os_name = sys.platform.lower()
    if os_name.startswith("linux"):
        return "linux"
    elif os_name.startswith("win"):
        return "windows"
    else:
        raise NotImplementedError(f"âŒ ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿï¼š{os_name}")


def is_target_server(ip, port, target_servers):
    """åˆ¤æ–­æ˜¯å¦ä¸ºç›®æ ‡ä¸‹æ¸¸æœåŠ¡å™¨ï¼ˆIP:ç«¯å£åŒ¹é…ï¼‰"""
    return (ip, port) in target_servers


def clean_timeout_connections(connection_states, timeout):
    """æ¸…ç†è¶…æ—¶æœªæ´»åŠ¨çš„è¿æ¥"""
    current_time = time.time()
    expired_keys = []
    for conn_key, state in connection_states.items():
        if current_time - state['last_active'] > timeout:
            expired_keys.append(conn_key)
    for key in expired_keys:
        del connection_states[key]


def output_log(log_msg, log_output):
    """è¾“å‡ºæ—¥å¿—ï¼ˆæ§åˆ¶å°/æ–‡ä»¶ï¼‰"""
    if log_output == "stdout":
        print(log_msg)
    else:
        try:
            with open(log_output, "a", encoding="utf-8") as f:
                f.write(log_msg + "\n")
        except Exception as e:
            print(f"âŒ å†™å…¥æ—¥å¿—æ–‡ä»¶å¤±è´¥ï¼š{str(e)}ï¼Œæ—¥å¿—å†…å®¹ï¼š{log_msg}", file=sys.stderr)


def monitor_logged_in_fix_connections(fix_servers, interval, timeout, log_output):
    """ä¸»ç›‘æ§é€»è¾‘ï¼šæ•è·æµé‡â†’è§£æFIXç™»å½•çŠ¶æ€â†’ç»Ÿè®¡è¾“å‡º"""
    os_type = get_os_type()
    target_servers = set(fix_servers)  # è½¬æ¢ä¸ºé›†åˆï¼ŒåŠ é€ŸåŒ¹é…
    sock = init_raw_socket(os_type)
    
    # è¿æ¥çŠ¶æ€è¡¨ï¼škey=(src_ip:src_port, dst_ip:dst_port)ï¼Œvalue={'is_logged_in': bool, 'last_active': float}
    connection_states = defaultdict(lambda: {'is_logged_in': False, 'last_active': time.time()})
    
    print(f"âœ… å¼€å§‹FIXå·²ç™»å½•è¿æ¥ç›‘æ§ | æ“ä½œç³»ç»Ÿï¼š{os_type} | ç»Ÿè®¡é—´éš”ï¼š{interval}ç§’ | è¶…æ—¶æ—¶é—´ï¼š{timeout}ç§’ | ç›®æ ‡æœåŠ¡å™¨ï¼š{fix_servers}")
    print(f"âš ï¸  æç¤ºï¼šç¨‹åºæ­£åœ¨æŠ“å–TCPæµé‡ï¼Œè¯·å‹¿ä¸­æ–­...ï¼ˆæŒ‰Ctrl+Cé€€å‡ºï¼‰")
    
    last_output_time = time.time()
    try:
        while True:
            current_time = time.time()
            try:
                # æ¥æ”¶æ•°æ®åŒ…ï¼ˆç¼“å†²åŒº1024å­—èŠ‚ï¼Œè¶³å¤Ÿå®¹çº³FIXæ¶ˆæ¯ç‰‡æ®µï¼‰
                data, _ = sock.recvfrom(1024)
                if not data:
                    continue
                
                # è§£æTCPæ•°æ®åŒ…
                tcp_info = parse_tcp_packet(data)
                if not tcp_info:
                    continue
                
                src_key = (tcp_info['src_ip'], tcp_info['src_port'])
                dst_key = (tcp_info['dst_ip'], tcp_info['dst_port'])
                conn_key = (f"{src_key[0]}:{src_key[1]}", f"{dst_key[0]}:{dst_key[1]}")
                
                # ä»…å…³æ³¨ç›®æ ‡æœåŠ¡å™¨çš„è¿æ¥ï¼ˆä¸‹æ¸¸æœåŠ¡å™¨ä½œä¸ºç›®æ ‡ç«¯ï¼Œå³å®¢æˆ·ç«¯â†’ä¸‹æ¸¸æœåŠ¡å™¨ï¼‰
                if not is_target_server(dst_key[0], dst_key[1], target_servers):
                    continue
                
                # æ›´æ–°è¿æ¥æœ€åæ´»åŠ¨æ—¶é—´
                connection_states[conn_key]['last_active'] = current_time
                
                # è§£æFIXæ¶ˆæ¯ç±»å‹ï¼ˆåˆ¤æ–­ç™»å½•/ç™»å‡ºï¼‰
                fix_msg_type = parse_fix_msg_type(tcp_info['data'])
                if fix_msg_type == FIX_LOGON_MSG_TYPE.decode():
                    # æ”¶åˆ°Logonæ¶ˆæ¯ï¼Œæ ‡è®°ä¸ºå·²ç™»å½•
                    connection_states[conn_key]['is_logged_in'] = True
                    print(f"â„¹ï¸  è¿æ¥ç™»å½•æˆåŠŸï¼š{conn_key[0]} â†’ {conn_key[1]}")
                elif fix_msg_type == FIX_LOGOUT_MSG_TYPE.decode():
                    # æ”¶åˆ°Logoutæ¶ˆæ¯ï¼Œæ ‡è®°ä¸ºæœªç™»å½•
                    connection_states[conn_key]['is_logged_in'] = False
                    print(f"â„¹ï¸  è¿æ¥ç™»å‡ºï¼š{conn_key[0]} â†’ {conn_key[1]}")
                
                # å®šæ—¶ç»Ÿè®¡è¾“å‡º
                if current_time - last_output_time >= interval:
                    # æ¸…ç†è¶…æ—¶è¿æ¥
                    clean_timeout_connections(connection_states, timeout)
                    # ç»Ÿè®¡å·²ç™»å½•çš„è¿æ¥æ•°
                    logged_in_count = 0
                    logged_in_details = []
                    for conn_key, state in connection_states.items():
                        if state['is_logged_in']:
                            logged_in_count += 1
                            logged_in_details.append(f"{conn_key[0]}â†’{conn_key[1]}")
                    # ç”Ÿæˆæ—¥å¿—
                    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
                    log_msg = f"[{timestamp}] å·²ç™»å½•FIXè¿æ¥æ•°ï¼š{logged_in_count} | æ€»æ´»è·ƒTCPè¿æ¥æ•°ï¼š{len(connection_states)}"
                    if logged_in_details:
                        log_msg += f" | å·²ç™»å½•è¿æ¥ï¼š{', '.join(logged_in_details)}"
                    output_log(log_msg, log_output)
                    last_output_time = current_time
            
            except Exception as e:
                # å¿½ç•¥å•ä¸ªæ•°æ®åŒ…çš„è§£æé”™è¯¯ï¼Œä¸å½±å“æ•´ä½“ç›‘æ§
                continue
        
    except KeyboardInterrupt:
        print("\nğŸ›‘ ç›‘æ§è¢«ç”¨æˆ·ä¸­æ–­ï¼Œæ­£åœ¨æ¸…ç†èµ„æº...")
    finally:
        # Windowså…³é—­æ··æ‚æ¨¡å¼
        if os_type == "windows":
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)
        sock.close()
        print("âœ… ç¨‹åºå·²é€€å‡º")


if __name__ == "__main__":
    args = parse_args()
    fix_servers = validate_servers(args.servers)
    monitor_logged_in_fix_connections(
        fix_servers=fix_servers,
        interval=args.interval,
        timeout=args.timeout,
        log_output=args.log
    )