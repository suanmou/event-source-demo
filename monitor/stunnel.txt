import socket
import struct
import time
import sys
import argparse
from collections import defaultdict
import fileinput
import re

# FIXåè®®å¸¸é‡ï¼ˆä¸ä¹‹å‰ä¸€è‡´ï¼‰
FIX_SOH = b'\x01'
FIX_LOGON_MSG_TYPE = b'A'
FIX_LOGOUT_MSG_TYPE = b'5'
FIX_MSGTYPE_TAG = b'35='

# stunnelæ—¥å¿—è§£ææ­£åˆ™ï¼ˆåŒ¹é…è¿æ¥æ˜ å°„ï¼šå®¢æˆ·ç«¯â†’stunnelâ†’ä¸‹æ¸¸ï¼‰
# ç¤ºä¾‹æ—¥å¿—è¡Œï¼š2025.01.01 10:00:00 LOG5[2000:12345]: CONNECTED: [10.0.0.1:54321] â†’ [192.168.1.100:9876]
STUNNEL_CONNECT_PATTERN = re.compile(
    r'CONNECTED: \[(?P<client_ip>[0-9.]+):(?P<client_port>\d+)\] â†’ \[(?P<downstream_ip>[0-9.]+):(?P<downstream_port>\d+)\]'
)
# ç¤ºä¾‹æ—¥å¿—è¡Œï¼š2025.01.01 10:05:00 LOG5[2000:12345]: CLOSED: [10.0.0.1:54321] â†’ [192.168.1.100:9876]
STUNNEL_CLOSE_PATTERN = re.compile(
    r'CLOSED: \[(?P<client_ip>[0-9.]+):(?P<client_port>\d+)\] â†’ \[(?P<downstream_ip>[0-9.]+):(?P<downstream_port>\d+)\]'
)

# é»˜è®¤é…ç½®
DEFAULT_STUNNEL_LISTEN_PORT = 9876  # stunnelç›‘å¬ç«¯å£ï¼ˆå®¢æˆ·ç«¯è¿æ¥ç«¯ï¼‰
DEFAULT_DOWNSTREAM_SERVERS = []  # ä¸‹æ¸¸æœåŠ¡å™¨ï¼ˆéœ€ä¸stunnel.confçš„connectä¸€è‡´ï¼‰
DEFAULT_STUNNEL_LOG = "/var/log/stunnel/stunnel.log"  # stunnelæ—¥å¿—è·¯å¾„
DEFAULT_MONITOR_INTERVAL = 60  # ç»Ÿè®¡é—´éš”ï¼ˆç§’ï¼‰
DEFAULT_TIMEOUT = 300  # è¿æ¥è¶…æ—¶ï¼ˆç§’ï¼‰
DEFAULT_LOG_OUTPUT = "stdout"


def parse_args():
    """è§£æå‘½ä»¤è¡Œå‚æ•°"""
    parser = argparse.ArgumentParser(description="stunnelä»£ç†åœºæ™¯-FIXå·²ç™»å½•è¿æ¥ç›‘æ§ï¼ˆæ— ç¬¬ä¸‰æ–¹ä¾èµ–ï¼‰")
    parser.add_argument(
        "-d", "--downstreams",
        type=str,
        nargs="+",
        required=True,
        help="ä¸‹æ¸¸FIXæœåŠ¡å™¨ï¼ˆå¿…å¡«ï¼Œéœ€ä¸stunnel.confçš„connectä¸€è‡´ï¼‰ï¼Œæ ¼å¼ï¼šIP:ç«¯å£ï¼Œä¾‹ï¼š192.168.1.100:9876"
    )
    parser.add_argument(
        "-l", "--stunnel-listen",
        type=int,
        default=DEFAULT_STUNNEL_LISTEN_PORT,
        help=f"stunnelç›‘å¬ç«¯å£ï¼ˆå®¢æˆ·ç«¯è¿æ¥ç«¯ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_STUNNEL_LISTEN_PORT}"
    )
    parser.add_argument(
        "-s", "--stunnel-log",
        type=str,
        default=DEFAULT_STUNNEL_LOG,
        help=f"stunnelæ—¥å¿—æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ï¼š{DEFAULT_STUNNEL_LOG}"
    )
    parser.add_argument(
        "-i", "--interval",
        type=int,
        default=DEFAULT_MONITOR_INTERVAL,
        help=f"ç»Ÿè®¡è¾“å‡ºé—´éš”ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_MONITOR_INTERVAL}"
    )
    parser.add_argument(
        "-t", "--timeout",
        type=int,
        default=DEFAULT_TIMEOUT,
        help=f"è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_TIMEOUT}"
    )
    parser.add_argument(
        "-o", "--output-log",
        type=str,
        default=DEFAULT_LOG_OUTPUT,
        help=f"ç›‘æ§æ—¥å¿—è¾“å‡ºæ–¹å¼ï¼Œstdoutï¼ˆæ§åˆ¶å°ï¼‰æˆ–æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ï¼š{DEFAULT_LOG_OUTPUT}"
    )
    return parser.parse_args()


def validate_servers(servers_str):
    """éªŒè¯æœåŠ¡å™¨æ ¼å¼ï¼ˆIP:ç«¯å£ï¼‰"""
    valid_servers = []
    for s in servers_str:
        if ":" not in s:
            print(f"âŒ æ— æ•ˆæœåŠ¡å™¨æ ¼å¼ï¼š{s}ï¼Œæ­£ç¡®æ ¼å¼ï¼šIP:ç«¯å£", file=sys.stderr)
            sys.exit(1)
        ip, port_str = s.split(":", 1)
        try:
            port = int(port_str)
            if not (1 <= port <= 65535):
                raise ValueError
            valid_servers.append((ip, port))
        except ValueError:
            print(f"âŒ æ— æ•ˆç«¯å£ï¼š{port_str}ï¼Œéœ€ä¸º1-65535çš„æ•´æ•°", file=sys.stderr)
            sys.exit(1)
    return valid_servers


def get_os_type():
    """è·å–æ“ä½œç³»ç»Ÿç±»å‹ï¼ˆlinux/windowsï¼‰"""
    os_name = sys.platform.lower()
    return "linux" if os_name.startswith("linux") else "windows" if os_name.startswith("win") else None


def init_raw_socket(os_type):
    """åˆå§‹åŒ–åŸå§‹å¥—æ¥å­—ï¼ˆæŠ“stunnelâ†’ä¸‹æ¸¸çš„æ˜æ–‡æµé‡ï¼‰"""
    try:
        if os_type == "linux":
            sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))
        elif os_type == "windows":
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
        else:
            raise NotImplementedError(f"âŒ ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿï¼š{os_type}")
        return sock
    except PermissionError:
        print("âŒ æƒé™ä¸è¶³ï¼è¯·ä»¥ç®¡ç†å‘˜ï¼ˆWindowsï¼‰æˆ–rootï¼ˆLinuxï¼‰èº«ä»½è¿è¡Œ", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"âŒ åˆå§‹åŒ–æŠ“åŒ…socketå¤±è´¥ï¼š{str(e)}", file=sys.stderr)
        sys.exit(1)


def parse_tcp_packet(data):
    """è§£æTCPæ•°æ®åŒ…ï¼Œæå–æºIP:ç«¯å£ã€ç›®æ ‡IP:ç«¯å£ã€è´Ÿè½½æ•°æ®"""
    try:
        # è§£æIPå¤´
        ip_header = data[:20]
        iph = struct.unpack('!BBHHHBBH4s4s', ip_header)
        if iph[6] != 6:  # ä»…å¤„ç†TCPåè®®
            return None
        src_ip = socket.inet_ntoa(iph[8])
        dst_ip = socket.inet_ntoa(iph[9])
        ip_header_len = (iph[0] & 0x0F) * 4

        # è§£æTCPå¤´
        tcp_header = data[ip_header_len:ip_header_len+20]
        tcph = struct.unpack('!HHLLBBHHH', tcp_header)
        src_port = tcph[0]
        dst_port = tcph[1]
        tcp_header_len = ((tcph[4] & 0xF0) >> 4) * 4

        # æå–TCPè´Ÿè½½ï¼ˆFIXæ¶ˆæ¯ï¼‰
        tcp_data = data[ip_header_len + tcp_header_len:]
        return {
            'src': (src_ip, src_port),
            'dst': (dst_ip, dst_port),
            'data': tcp_data
        } if tcp_data else None
    except Exception:
        return None


def parse_fix_msg_type(tcp_data):
    """è§£æFIXæ¶ˆæ¯çš„MsgTypeï¼ˆç™»å½•/ç™»å‡ºï¼‰"""
    fields = tcp_data.split(FIX_SOH)
    for field in fields:
        if field.startswith(FIX_MSGTYPE_TAG):
            msg_type = field[len(FIX_MSGTYPE_TAG):].decode('ascii', errors='ignore')
            return msg_type if msg_type in ['A', '5'] else None
    return None


def parse_stunnel_log(log_path, client_forward_map, forward_client_map):
    """å®æ—¶è§£æstunnelæ—¥å¿—ï¼Œæ›´æ–°è¿æ¥æ˜ å°„ï¼ˆå®¢æˆ·ç«¯â†’è½¬å‘è¿æ¥ï¼‰"""
    try:
        # ä»¥å°¾éƒ¨è·Ÿéšæ¨¡å¼è¯»å–æ—¥å¿—ï¼ˆç±»ä¼¼tail -fï¼‰
        for line in fileinput.input(log_path, follow=True):
            line = line.strip()
            # åŒ¹é…è¿æ¥å»ºç«‹æ—¥å¿—ï¼ˆå®¢æˆ·ç«¯â†’ä¸‹æ¸¸ï¼‰
            connect_match = STUNNEL_CONNECT_PATTERN.search(line)
            if connect_match:
                client_ip = connect_match.group('client_ip')
                client_port = int(connect_match.group('client_port'))
                downstream_ip = connect_match.group('downstream_ip')
                downstream_port = int(connect_match.group('downstream_port'))
                client_key = (client_ip, client_port)
                # è½¬å‘è¿æ¥çš„æ ‡è¯†ï¼šstunnelå‡ºå£IP:ç«¯å£â†’ä¸‹æ¸¸IP:ç«¯å£ï¼ˆstunnelå‡ºå£IPéœ€åç»­é€šè¿‡æŠ“åŒ…è¡¥å……ï¼‰
                # å…ˆæš‚å­˜å®¢æˆ·ç«¯ä¸ä¸‹æ¸¸çš„æ˜ å°„ï¼Œåç»­æŠ“åŒ…æ—¶åŒ¹é…ä¸‹æ¸¸ä¿¡æ¯
                client_forward_map[client_key] = {
                    'downstream': (downstream_ip, downstream_port),
                    'forward_key': None,  # åç»­ç”±æŠ“åŒ…å¡«å……ï¼ˆstunnel_src_ip:stunnel_src_portï¼‰
                    'last_active': time.time()
                }
                print(f"â„¹ï¸  stunnelè¿æ¥å»ºç«‹ï¼š{client_key[0]}:{client_key[1]} â†’ {downstream_ip}:{downstream_port}")
            
            # åŒ¹é…è¿æ¥å…³é—­æ—¥å¿—
            close_match = STUNNEL_CLOSE_PATTERN.search(line)
            if close_match:
                client_ip = close_match.group('client_ip')
                client_port = int(close_match.group('client_port'))
                client_key = (client_ip, client_port)
                if client_key in client_forward_map:
                    # ç§»é™¤å…³é—­çš„è¿æ¥æ˜ å°„
                    forward_key = client_forward_map[client_key]['forward_key']
                    if forward_key in forward_client_map:
                        del forward_client_map[forward_key]
                    del client_forward_map[client_key]
                    print(f"â„¹ï¸  stunnelè¿æ¥å…³é—­ï¼š{client_ip}:{client_port}")
    except FileNotFoundError:
        print(f"âŒ stunnelæ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨ï¼š{log_path}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"âš ï¸  è§£æstunnelæ—¥å¿—å¼‚å¸¸ï¼š{str(e)}", file=sys.stderr)


def associate_forward_connection(tcp_info, client_forward_map, forward_client_map):
    """å…³è”è½¬å‘è¿æ¥ï¼ˆstunnelâ†’ä¸‹æ¸¸ï¼‰ä¸å®¢æˆ·ç«¯è¿æ¥ï¼ˆå®¢æˆ·ç«¯â†’stunnelï¼‰"""
    forward_src = tcp_info['src']  # stunnelå‡ºå£IP:ç«¯å£
    forward_dst = tcp_info['dst']  # ä¸‹æ¸¸IP:ç«¯å£
    forward_key = (f"{forward_src[0]}:{forward_src[1]}", f"{forward_dst[0]}:{forward_dst[1]}")

    # éå†å®¢æˆ·ç«¯æ˜ å°„ï¼ŒåŒ¹é…ä¸‹æ¸¸ä¿¡æ¯ï¼Œå…³è”è½¬å‘è¿æ¥
    for client_key, info in client_forward_map.items():
        if info['downstream'] == forward_dst and info['forward_key'] is None:
            info['forward_key'] = forward_key
            info['last_active'] = time.time()
            forward_client_map[forward_key] = client_key
            print(f"â„¹ï¸  è¿æ¥å…³è”æˆåŠŸï¼š{client_key[0]}:{client_key[1]} â†” {forward_key[0]}â†’{forward_key[1]}")
            break
    return forward_key


def clean_timeout_connections(client_forward_map, forward_client_map, login_states, timeout):
    """æ¸…ç†è¶…æ—¶è¿æ¥ï¼ˆå®¢æˆ·ç«¯è¿æ¥å’Œè½¬å‘è¿æ¥ï¼‰"""
    current_time = time.time()
    expired_clients = []
    for client_key, info in client_forward_map.items():
        if current_time - info['last_active'] > timeout:
            expired_clients.append(client_key)
    for client_key in expired_clients:
        forward_key = client_forward_map[client_key]['forward_key']
        if forward_key in forward_client_map:
            del forward_client_map[forward_key]
            if forward_key in login_states:
                del login_states[forward_key]
        del client_forward_map[client_key]
        print(f"âš ï¸  å®¢æˆ·ç«¯è¿æ¥è¶…æ—¶ç§»é™¤ï¼š{client_key[0]}:{client_key[1]}")


def output_log(log_msg, output_path):
    """è¾“å‡ºç›‘æ§æ—¥å¿—"""
    if output_path == "stdout":
        print(log_msg)
    else:
        try:
            with open(output_path, "a", encoding="utf-8") as f:
                f.write(log_msg + "\n")
        except Exception as e:
            print(f"âŒ å†™å…¥ç›‘æ§æ—¥å¿—å¤±è´¥ï¼š{str(e)}", file=sys.stderr)


def main():
    args = parse_args()
    downstream_servers = validate_servers(args.downstreams)
    downstream_set = set(downstream_servers)
    os_type = get_os_type()
    if not os_type:
        print(f"âŒ ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿï¼š{sys.platform}", file=sys.stderr)
        sys.exit(1)

    # åˆå§‹åŒ–èµ„æº
    sock = init_raw_socket(os_type)
    # è¿æ¥æ˜ å°„ï¼šclient_key=(client_ip, client_port) â†’ è½¬å‘ä¿¡æ¯
    client_forward_map = dict()
    # åå‘æ˜ å°„ï¼šforward_key=(stunnel_src:portâ†’downstream_ip:port) â†’ client_key
    forward_client_map = dict()
    # ç™»å½•çŠ¶æ€ï¼šforward_key â†’ is_logged_inï¼ˆboolï¼‰
    login_states = defaultdict(bool)

    print(f"âœ… å¼€å§‹stunnelä»£ç†åœºæ™¯-FIXç™»å½•è¿æ¥ç›‘æ§")
    print(f"ğŸ“‹ é…ç½®ä¿¡æ¯ï¼šstunnelç›‘å¬ç«¯å£={args.stunnel_listen} | ä¸‹æ¸¸æœåŠ¡å™¨={downstream_servers} | "
          f"stunnelæ—¥å¿—={args.stunnel_log} | ç»Ÿè®¡é—´éš”={args.interval}ç§’ | è¶…æ—¶={args.timeout}ç§’")
    print(f"âš ï¸  æç¤ºï¼šæŒ‰Ctrl+Cé€€å‡ºï¼Œç¡®ä¿stunnelé…ç½®debugâ‰¥3ä¸”ä¸ä¸‹æ¸¸ä¸ºæ˜æ–‡é€šä¿¡")

    # å¯åŠ¨å­çº¿ç¨‹è§£æstunnelæ—¥å¿—ï¼ˆå®æ—¶æ›´æ–°è¿æ¥æ˜ å°„ï¼‰
    import threading
    log_thread = threading.Thread(
        target=parse_stunnel_log,
        args=(args.stunnel_log, client_forward_map, forward_client_map),
        daemon=True  # ä¸»çº¿ç¨‹é€€å‡ºæ—¶å­çº¿ç¨‹è‡ªåŠ¨é€€å‡º
    )
    log_thread.start()

    last_stat_time = time.time()
    try:
        while True:
            current_time = time.time()
            try:
                # æ¥æ”¶TCPæ•°æ®åŒ…ï¼ˆæŠ“stunnelâ†’ä¸‹æ¸¸çš„æµé‡ï¼‰
                data, _ = sock.recvfrom(4096)
                tcp_info = parse_tcp_packet(data)
                if not tcp_info:
                    continue

                # ä»…å…³æ³¨stunnelâ†’ä¸‹æ¸¸çš„æµé‡ï¼ˆç›®æ ‡æ˜¯ä¸‹æ¸¸æœåŠ¡å™¨ï¼‰
                if tcp_info['dst'] not in downstream_set:
                    continue

                # å…³è”è½¬å‘è¿æ¥ä¸å®¢æˆ·ç«¯è¿æ¥
                forward_key = associate_forward_connection(tcp_info, client_forward_map, forward_client_map)
                if forward_key not in forward_client_map:
                    continue  # æœªå…³è”åˆ°å®¢æˆ·ç«¯çš„è½¬å‘è¿æ¥ï¼Œè·³è¿‡

                # æ›´æ–°è¿æ¥æ´»åŠ¨æ—¶é—´
                client_key = forward_client_map[forward_key]
                if client_key in client_forward_map:
                    client_forward_map[client_key]['last_active'] = current_time

                # è§£æFIXç™»å½•/ç™»å‡ºæ¶ˆæ¯
                fix_msg_type = parse_fix_msg_type(tcp_info['data'])
                if fix_msg_type == 'A':
                    login_states[forward_key] = True
                    print(f"âœ… ç™»å½•æˆåŠŸï¼š{client_key[0]}:{client_key[1]} â†’ {forward_key[1]}")
                elif fix_msg_type == '5':
                    login_states[forward_key] = False
                    print(f"âŒ ç™»å‡ºï¼š{client_key[0]}:{client_key[1]} â†’ {forward_key[1]}")

                # å®šæ—¶ç»Ÿè®¡è¾“å‡º
                if current_time - last_stat_time >= args.interval:
                    # æ¸…ç†è¶…æ—¶è¿æ¥
                    clean_timeout_connections(client_forward_map, forward_client_map, login_states, args.timeout)
                    # ç»Ÿè®¡å·²ç™»å½•çš„å®¢æˆ·ç«¯è¿æ¥æ•°
                    logged_in_count = 0
                    logged_in_details = []
                    for forward_key, is_logged in login_states.items():
                        if is_logged and forward_key in forward_client_map:
                            client_key = forward_client_map[forward_key]
                            logged_in_count += 1
                            logged_in_details.append(f"{client_key[0]}:{client_key[1]}")
                    # ç”Ÿæˆæ—¥å¿—
                    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
                    log_msg = (
                        f"[{timestamp}] å·²ç™»å½•FIXè¿æ¥æ•°ï¼š{logged_in_count} | "
                        f"æ´»è·ƒå®¢æˆ·ç«¯è¿æ¥æ•°ï¼š{len(client_forward_map)} | "
                        f"å·²ç™»å½•å®¢æˆ·ç«¯ï¼š{', '.join(logged_in_details) if logged_in_details else 'æ— '}"
                    )
                    output_log(log_msg, args.output_log)
                    last_stat_time = current_time

            except Exception as e:
                # å¿½ç•¥å•ä¸ªæ•°æ®åŒ…è§£æé”™è¯¯
                continue

    except KeyboardInterrupt:
        print("\nğŸ›‘ ç›‘æ§è¢«ç”¨æˆ·ä¸­æ–­ï¼Œæ­£åœ¨æ¸…ç†èµ„æº...")
    finally:
        # å…³é—­èµ„æº
        if os_type == "windows":
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)
        sock.close()
        print("âœ… ç¨‹åºå·²é€€å‡º")


if __name__ == "__main__":
    main()