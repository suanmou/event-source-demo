import socket
import struct
import time
import sys
import argparse
from collections import defaultdict
import fileinput
import re

# FIXåè®®å¸¸é‡ï¼ˆä¸ä¹‹å‰ä¸€è‡´ï¼‰
FIX_SOH = b'\x01'
FIX_LOGON_MSG_TYPE = b'A'
FIX_LOGOUT_MSG_TYPE = b'5'
FIX_MSGTYPE_TAG = b'35='

# stunnelæ—¥å¿—è§£ææ­£åˆ™ï¼ˆåŒ¹é…è¿æ¥æ˜ å°„ï¼šå®¢æˆ·ç«¯â†’stunnelâ†’ä¸‹æ¸¸ï¼‰
# ç¤ºä¾‹æ—¥å¿—è¡Œï¼š2025.01.01 10:00:00 LOG5[2000:12345]: CONNECTED: [10.0.0.1:54321] â†’ [192.168.1.100:9876]
STUNNEL_CONNECT_PATTERN = re.compile(
    r'CONNECTED: \[(?P<client_ip>[0-9.]+):(?P<client_port>\d+)\] â†’ \[(?P<downstream_ip>[0-9.]+):(?P<downstream_port>\d+)\]'
)
# ç¤ºä¾‹æ—¥å¿—è¡Œï¼š2025.01.01 10:05:00 LOG5[2000:12345]: CLOSED: [10.0.0.1:54321] â†’ [192.168.1.100:9876]
STUNNEL_CLOSE_PATTERN = re.compile(
    r'CLOSED: \[(?P<client_ip>[0-9.]+):(?P<client_port>\d+)\] â†’ \[(?P<downstream_ip>[0-9.]+):(?P<downstream_port>\d+)\]'
)

# é»˜è®¤é…ç½®
DEFAULT_STUNNEL_LISTEN_PORT = 9876  # stunnelç›‘å¬ç«¯å£ï¼ˆå®¢æˆ·ç«¯è¿æ¥ç«¯ï¼‰
DEFAULT_DOWNSTREAM_SERVERS = []  # ä¸‹æ¸¸æœåŠ¡å™¨ï¼ˆéœ€ä¸stunnel.confçš„connectä¸€è‡´ï¼‰
DEFAULT_STUNNEL_LOG = "/var/log/stunnel/stunnel.log"  # stunnelæ—¥å¿—è·¯å¾„
DEFAULT_MONITOR_INTERVAL = 60  # ç»Ÿè®¡é—´éš”ï¼ˆç§’ï¼‰
DEFAULT_TIMEOUT = 300  # è¿æ¥è¶…æ—¶ï¼ˆç§’ï¼‰
DEFAULT_LOG_OUTPUT = "stdout"


def parse_args():
    """è§£æå‘½ä»¤è¡Œå‚æ•°"""
    parser = argparse.ArgumentParser(description="stunnelä»£ç†åœºæ™¯-FIXå·²ç™»å½•è¿æ¥ç›‘æ§ï¼ˆæ— ç¬¬ä¸‰æ–¹ä¾èµ–ï¼‰")
    parser.add_argument(
        "-d", "--downstreams",
        type=str,
        nargs="+",
        required=True,
        help="ä¸‹æ¸¸FIXæœåŠ¡å™¨ï¼ˆå¿…å¡«ï¼Œéœ€ä¸stunnel.confçš„connectä¸€è‡´ï¼‰ï¼Œæ ¼å¼ï¼šIP:ç«¯å£ï¼Œä¾‹ï¼š192.168.1.100:9876"
    )
    parser.add_argument(
        "-l", "--stunnel-listen",
        type=int,
        default=DEFAULT_STUNNEL_LISTEN_PORT,
        help=f"stunnelç›‘å¬ç«¯å£ï¼ˆå®¢æˆ·ç«¯è¿æ¥ç«¯ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_STUNNEL_LISTEN_PORT}"
    )
    parser.add_argument(
        "-s", "--stunnel-log",
        type=str,
        default=DEFAULT_STUNNEL_LOG,
        help=f"stunnelæ—¥å¿—æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ï¼š{DEFAULT_STUNNEL_LOG}"
    )
    parser.add_argument(
        "-i", "--interval",
        type=int,
        default=DEFAULT_MONITOR_INTERVAL,
        help=f"ç»Ÿè®¡è¾“å‡ºé—´éš”ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_MONITOR_INTERVAL}"
    )
    parser.add_argument(
        "-t", "--timeout",
        type=int,
        default=DEFAULT_TIMEOUT,
        help=f"è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ï¼š{DEFAULT_TIMEOUT}"
    )
    parser.add_argument(
        "-o", "--output-log",
        type=str,
        default=DEFAULT_LOG_OUTPUT,
        help=f"ç›‘æ§æ—¥å¿—è¾“å‡ºæ–¹å¼ï¼Œstdoutï¼ˆæ§åˆ¶å°ï¼‰æˆ–æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ï¼š{DEFAULT_LOG_OUTPUT}"
    )
    return parser.parse_args()


def validate_servers(servers_str):
    """éªŒè¯æœåŠ¡å™¨æ ¼å¼ï¼ˆIP:ç«¯å£ï¼‰"""
    valid_servers = []
    for s in servers_str:
        if ":" not in s:
            print(f"âŒ æ— æ•ˆæœåŠ¡å™¨æ ¼å¼ï¼š{s}ï¼Œæ­£ç¡®æ ¼å¼ï¼šIP:ç«¯å£", file=sys.stderr)
            sys.exit(1)
        ip, port_str = s.split(":", 1)
        try:
            port = int(port_str)
            if not (1 <= port <= 65535):
                raise ValueError
            valid_servers.append((ip, port))
        except ValueError:
            print(f"âŒ æ— æ•ˆç«¯å£ï¼š{port_str}ï¼Œéœ€ä¸º1-65535çš„æ•´æ•°", file=sys.stderr)
            sys.exit(1)
    return valid_servers


def get_os_type():
    """è·å–æ“ä½œç³»ç»Ÿç±»å‹ï¼ˆlinux/windowsï¼‰"""
    os_name = sys.platform.lower()
    return "linux" if os_name.startswith("linux") else "windows" if os_name.startswith("win") else None


def init_raw_socket(os_type):
    """åˆå§‹åŒ–åŸå§‹å¥—æ¥å­—ï¼ˆæŠ“stunnelâ†’ä¸‹æ¸¸çš„æ˜æ–‡æµé‡ï¼‰"""
    try:
        if os_type == "linux":
            sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))
        elif os_type == "windows":
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
        else:
            raise NotImplementedError(f"âŒ ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿï¼š{os_type}")
        return sock
    except PermissionError:
        print("âŒ æƒé™ä¸è¶³ï¼è¯·ä»¥ç®¡ç†å‘˜ï¼ˆWindowsï¼‰æˆ–rootï¼ˆLinuxï¼‰èº«ä»½è¿è¡Œ", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"âŒ åˆå§‹åŒ–æŠ“åŒ…socketå¤±è´¥ï¼š{str(e)}", file=sys.stderr)
        sys.exit(1)


def parse_tcp_packet(data):
    """è§£æTCPæ•°æ®åŒ…ï¼Œæå–æºIP:ç«¯å£ã€ç›®æ ‡IP:ç«¯å£ã€è´Ÿè½½æ•°æ®"""
    try:
        # è§£æIPå¤´
        ip_header = data[:20]
        iph = struct.unpack('!BBHHHBBH4s4s', ip_header)
        if iph[6] != 6:  # ä»…å¤„ç†TCPåè®®
            return None
        src_ip = socket.inet_ntoa(iph[8])
        dst_ip = socket.inet_ntoa(iph[9])
        ip_header_len = (iph[0] & 0x0F) * 4

        # è§£æTCPå¤´
        tcp_header = data[ip_header_len:ip_header_len+20]
        tcph = struct.unpack('!HHLLBBHHH', tcp_header)
        src_port = tcph[0]
        dst_port = tcph[1]
        tcp_header_len = ((tcph[4] & 0xF0) >> 4) * 4

        # æå–TCPè´Ÿè½½ï¼ˆFIXæ¶ˆæ¯ï¼‰
        tcp_data = data[ip_header_len + tcp_header_len:]
        return {
            'src': (src_ip, src_port),
            'dst': (dst_ip, dst_port),
            'data': tcp_data
        } if tcp_data else None
    except Exception:
        return None


def parse_fix_msg_type(tcp_data):
    """è§£æFIXæ¶ˆæ¯çš„MsgTypeï¼ˆç™»å½•/ç™»å‡ºï¼‰"""
    fields = tcp_data.split(FIX_SOH)
    for field in fields:
        if field.startswith(FIX_MSGTYPE_TAG):
            msg_type = field[len(FIX_MSGTYPE_TAG):].decode('ascii', errors='ignore')
            return msg_type if msg_type in ['A', '5'] else None
    return None


def parse_stunnel_log(log_path, client_forward_map, forward_client_map):
    """å®æ—¶è§£æstunnelæ—¥å¿—ï¼Œæ›´æ–°è¿æ¥æ˜ å°„ï¼ˆå®¢æˆ·ç«¯â†’è½¬å‘è¿æ¥ï¼‰"""
    try:
        # ä»¥å°¾éƒ¨è·Ÿéšæ¨¡å¼è¯»å–æ—¥å¿—ï¼ˆç±»ä¼¼tail -fï¼‰
        for line in fileinput.input(log_path, follow=True):
            line = line.strip()
            # åŒ¹é…è¿æ¥å»ºç«‹æ—¥å¿—ï¼ˆå®¢æˆ·ç«¯â†’ä¸‹æ¸¸ï¼‰
            connect_match = STUNNEL_CONNECT_PATTERN.search(line)
            if connect_match:
                client_ip = connect_match.group('client_ip')
                client_port = int(connect_match.group('client_port'))
                downstream_ip = connect_match.group('downstream_ip')
                downstream_port = int(connect_match.group('downstream_port'))
                client_key = (client_ip, client_port)
                # è½¬å‘è¿æ¥çš„æ ‡è¯†ï¼šstunnelå‡ºå£IP:ç«¯å£â†’ä¸‹æ¸¸IP:ç«¯å£ï¼ˆstunnelå‡ºå£IPéœ€åç»­é€šè¿‡æŠ“åŒ…è¡¥å……ï¼‰
                # å…ˆæš‚å­˜å®¢æˆ·ç«¯ä¸ä¸‹æ¸¸çš„æ˜ å°„ï¼Œåç»­æŠ“åŒ…æ—¶åŒ¹é…ä¸‹æ¸¸ä¿¡æ¯
                client_forward_map[client_key] = {
                    'downstream': (downstream_ip, downstream_port),
                    'forward_key': None,  # åç»­ç”±æŠ“åŒ…å¡«å……ï¼ˆstunnel_src_ip:stunnel_src_portï¼‰
                    'last_active': time.time()
                }
                print(f"â„¹ï¸  stunnelè¿æ¥å»ºç«‹ï¼š{client_key[0]}:{client_key[1]} â†’ {downstream_ip}:{downstream_port}")
            
            # åŒ¹é…è¿æ¥å…³é—­æ—¥å¿—
            close_match = STUNNEL_CLOSE_PATTERN.search(line)
            if close_match:
                client_ip = close_match.group('client_ip')
                client_port = int(close_match.group('client_port'))
                client_key = (client_ip, client_port)
                if client_key in client_forward_map:
                    # ç§»é™¤å…³é—­çš„è¿æ¥æ˜ å°„
                    forward_key = client_forward_map[client_key]['forward_key']
                    if forward_key in forward_client_map:
                        del forward_client_map[forward_key]
                    del client_forward_map[client_key]
                    print(f"â„¹ï¸  stunnelè¿æ¥å…³é—­ï¼š{client_ip}:{client_port}")
    except FileNotFoundError:
        print(f"âŒ stunnelæ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨ï¼š{log_path}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"âš ï¸  è§£æstunnelæ—¥å¿—å¼‚å¸¸ï¼š{str(e)}", file=sys.stderr)


def associate_forward_connection(tcp_info, client_forward_map, forward_client_map):
    """å…³è”è½¬å‘è¿æ¥ï¼ˆstunnelâ†’ä¸‹æ¸¸ï¼‰ä¸å®¢æˆ·ç«¯è¿æ¥ï¼ˆå®¢æˆ·ç«¯â†’stunnelï¼‰"""
    forward_src = tcp_info['src']  # stunnelå‡ºå£IP:ç«¯å£
    forward_dst = tcp_info['dst']  # ä¸‹æ¸¸IP:ç«¯å£
    forward_key = (f"{forward_src[0]}:{forward_src[1]}", f"{forward_dst[0]}:{forward_dst[1]}")

    # éå†å®¢æˆ·ç«¯æ˜ å°„ï¼ŒåŒ¹é…ä¸‹æ¸¸ä¿¡æ¯ï¼Œå…³è”è½¬å‘è¿æ¥
    for client_key, info in client_forward_map.items():
        if info['downstream'] == forward_dst and info['forward_key'] is None:
            info['forward_key'] = forward_key
            info['last_active'] = time.time()
            forward_client_map[forward_key] = client_key
            print(f"â„¹ï¸  è¿æ¥å…³è”æˆåŠŸï¼š{client_key[0]}:{client_key[1]} â†” {forward_key[0]}â†’{forward_key[1]}")
            break
    return forward_key


def clean_timeout_connections(client_forward_map, forward_client_map, login_states, timeout):
    """æ¸…ç†è¶…æ—¶è¿æ¥ï¼ˆå®¢æˆ·ç«¯è¿æ¥å’Œè½¬å‘è¿æ¥ï¼‰"""
    current_time = time.time()
    expired_clients = []
    for client_key, info in client_forward_map.items():
        if current_time - info['last_active'] > timeout:
            expired_clients.append(client_key)
    for client_key in expired_clients:
        forward_key = client_forward_map[client_key]['forward_key']
        if forward_key in forward_client_map:
            del forward_client_map[forward_key]
            if forward_key in login_states:
                del login_states[forward_key]
        del client_forward_map[client_key]
        print(f"âš ï¸  å®¢æˆ·ç«¯è¿æ¥è¶…æ—¶ç§»é™¤ï¼š{client_key[0]}:{client_key[1]}")


def output_log(log_msg, output_path):
    """è¾“å‡ºç›‘æ§æ—¥å¿—"""
    if output_path == "stdout":
        print(log_msg)
    else:
        try:
            with open(output_path, "a", encoding="utf-8") as f:
                f.write(log_msg + "\n")
        except Exception as e:
            print(f"âŒ å†™å…¥ç›‘æ§æ—¥å¿—å¤±è´¥ï¼š{str(e)}", file=sys.stderr)


def main():
    args = parse_args()
    downstream_servers = validate_servers(args.downstreams)
    downstream_set = set(downstream_servers)
    os_type = get_os_type()
    if not os_type:
        print(f"âŒ ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿï¼š{sys.platform}", file=sys.stderr)
        sys.exit(1)

    # åˆå§‹åŒ–èµ„æº
    sock = init_raw_socket(os_type)
    # è¿æ¥æ˜ å°„ï¼šclient_key=(client_ip, client_port) â†’ è½¬å‘ä¿¡æ¯
    client_forward_map = dict()
    # åå‘æ˜ å°„ï¼šforward_key=(stunnel_src:portâ†’downstream_ip:port) â†’ client_key
    forward_client_map = dict()
    # ç™»å½•çŠ¶æ€ï¼šforward_key â†’ is_logged_inï¼ˆboolï¼‰
    login_states = defaultdict(bool)

    print(f"âœ… å¼€å§‹stunnelä»£ç†åœºæ™¯-FIXç™»å½•è¿æ¥ç›‘æ§")
    print(f"ğŸ“‹ é…ç½®ä¿¡æ¯ï¼šstunnelç›‘å¬ç«¯å£={args.stunnel_listen} | ä¸‹æ¸¸æœåŠ¡å™¨={downstream_servers} | "
          f"stunnelæ—¥å¿—={args.stunnel_log} | ç»Ÿè®¡é—´éš”={args.interval}ç§’ | è¶…æ—¶={args.timeout}ç§’")
    print(f"âš ï¸  æç¤ºï¼šæŒ‰Ctrl+Cé€€å‡ºï¼Œç¡®ä¿stunnelé…ç½®debugâ‰¥3ä¸”ä¸ä¸‹æ¸¸ä¸ºæ˜æ–‡é€šä¿¡")

    # å¯åŠ¨å­çº¿ç¨‹è§£æstunnelæ—¥å¿—ï¼ˆå®æ—¶æ›´æ–°è¿æ¥æ˜ å°„ï¼‰
    import threading
    log_thread = threading.Thread(
        target=parse_stunnel_log,
        args=(args.stunnel_log, client_forward_map, forward_client_map),
        daemon=True  # ä¸»çº¿ç¨‹é€€å‡ºæ—¶å­çº¿ç¨‹è‡ªåŠ¨é€€å‡º
    )
    log_thread.start()

    last_stat_time = time.time()
    try:
        while True:
            current_time = time.time()
            try:
                # æ¥æ”¶TCPæ•°æ®åŒ…ï¼ˆæŠ“stunnelâ†’ä¸‹æ¸¸çš„æµé‡ï¼‰
                data, _ = sock.recvfrom(4096)
                tcp_info = parse_tcp_packet(data)
                if not tcp_info:
                    continue

                # ä»…å…³æ³¨stunnelâ†’ä¸‹æ¸¸çš„æµé‡ï¼ˆç›®æ ‡æ˜¯ä¸‹æ¸¸æœåŠ¡å™¨ï¼‰
                if tcp_info['dst'] not in downstream_set:
                    continue

                # å…³è”è½¬å‘è¿æ¥ä¸å®¢æˆ·ç«¯è¿æ¥
                forward_key = associate_forward_connection(tcp_info, client_forward_map, forward_client_map)
                if forward_key not in forward_client_map:
                    continue  # æœªå…³è”åˆ°å®¢æˆ·ç«¯çš„è½¬å‘è¿æ¥ï¼Œè·³è¿‡

                # æ›´æ–°è¿æ¥æ´»åŠ¨æ—¶é—´
                client_key = forward_client_map[forward_key]
                if client_key in client_forward_map:
                    client_forward_map[client_key]['last_active'] = current_time

                # è§£æFIXç™»å½•/ç™»å‡ºæ¶ˆæ¯
                fix_msg_type = parse_fix_msg_type(tcp_info['data'])
                if fix_msg_type == 'A':
                    login_states[forward_key] = True
                    print(f"âœ… ç™»å½•æˆåŠŸï¼š{client_key[0]}:{client_key[1]} â†’ {forward_key[1]}")
                elif fix_msg_type == '5':
                    login_states[forward_key] = False
                    print(f"âŒ ç™»å‡ºï¼š{client_key[0]}:{client_key[1]} â†’ {forward_key[1]}")

                # å®šæ—¶ç»Ÿè®¡è¾“å‡º
                if current_time - last_stat_time >= args.interval:
                    # æ¸…ç†è¶…æ—¶è¿æ¥
                    clean_timeout_connections(client_forward_map, forward_client_map, login_states, args.timeout)
                    # ç»Ÿè®¡å·²ç™»å½•çš„å®¢æˆ·ç«¯è¿æ¥æ•°
                    logged_in_count = 0
                    logged_in_details = []
                    for forward_key, is_logged in login_states.items():
                        if is_logged and forward_key in forward_client_map:
                            client_key = forward_client_map[forward_key]
                            logged_in_count += 1
                            logged_in_details.append(f"{client_key[0]}:{client_key[1]}")
                    # ç”Ÿæˆæ—¥å¿—
                    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
                    log_msg = (
                        f"[{timestamp}] å·²ç™»å½•FIXè¿æ¥æ•°ï¼š{logged_in_count} | "
                        f"æ´»è·ƒå®¢æˆ·ç«¯è¿æ¥æ•°ï¼š{len(client_forward_map)} | "
                        f"å·²ç™»å½•å®¢æˆ·ç«¯ï¼š{', '.join(logged_in_details) if logged_in_details else 'æ— '}"
                    )
                    output_log(log_msg, args.output_log)
                    last_stat_time = current_time

            except Exception as e:
                # å¿½ç•¥å•ä¸ªæ•°æ®åŒ…è§£æé”™è¯¯
                continue

    except KeyboardInterrupt:
        print("\nğŸ›‘ ç›‘æ§è¢«ç”¨æˆ·ä¸­æ–­ï¼Œæ­£åœ¨æ¸…ç†èµ„æº...")
    finally:
        # å…³é—­èµ„æº
        if os_type == "windows":
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)
        sock.close()
        print("âœ… ç¨‹åºå·²é€€å‡º")


if __name__ == "__main__":
    main()




import socket
import struct
import time
import sys
import argparse
from collections import defaultdict
import fileinput
import re
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer  # Python2ï¼›Python3ç”¨http.server
import threading

# ========== åŸºç¡€å¸¸é‡ï¼ˆä¸å˜ï¼‰ ==========
FIX_SOH = b'\x01'
FIX_LOGON_MSG_TYPE = b'A'
FIX_LOGOUT_MSG_TYPE = b'5'
FIX_MSGTYPE_TAG = b'35='
STUNNEL_CONNECT_PATTERN = re.compile(
    r'CONNECTED: \[(?P<client_ip>[0-9.]+):(?P<client_port>\d+)\] â†’ \[(?P<downstream_ip>[0-9.]+):(?P<downstream_port>\d+)\]'
)
STUNNEL_CLOSE_PATTERN = re.compile(
    r'CLOSED: \[(?P<client_ip>[0-9.]+):(?P<client_port>\d+)\] â†’ \[(?P<downstream_ip>[0-9.]+):(?P<downstream_port>\d+)\]'
)

# ========== å…¨å±€æŒ‡æ ‡å­˜å‚¨ï¼ˆä¾›Prometheusæ‹‰å–ï¼‰ ==========
# ç»“æ„ï¼š{æŒ‡æ ‡å: {æ ‡ç­¾å­—å…¸: æ•°å€¼}}
metrics = {
    "fix_logged_in_connections": defaultdict(float),  # å·²ç™»å½•FIXè¿æ¥æ•°ï¼ˆGaugeï¼‰
    "fix_active_client_connections": defaultdict(float),  # æ´»è·ƒå®¢æˆ·ç«¯è¿æ¥æ•°ï¼ˆGaugeï¼‰
    "fix_forward_connections": defaultdict(float),  # æ´»è·ƒè½¬å‘è¿æ¥æ•°ï¼ˆGaugeï¼‰
    "fix_connection_status": defaultdict(float),  # å•ä¸ªå®¢æˆ·ç«¯ç™»å½•çŠ¶æ€ï¼ˆ1=ç™»å½•ï¼Œ0=æœªç™»å½•ï¼‰
}

# ========== é…ç½®é»˜è®¤å€¼ ==========
DEFAULT_STUNNEL_LISTEN_PORT = 9876
DEFAULT_DOWNSTREAM_SERVERS = []
DEFAULT_STUNNEL_LOG = "/var/log/stunnel/stunnel.log"
DEFAULT_MONITOR_INTERVAL = 10  # æŒ‡æ ‡æ›´æ–°é—´éš”ï¼ˆç§’ï¼Œéœ€â‰¤Prometheusæ‹‰å–é—´éš”ï¼‰
DEFAULT_TIMEOUT = 300
DEFAULT_EXPORTER_PORT = 9101  # Exporteræš´éœ²ç«¯å£ï¼ˆç»Ÿä¸€å¤šæœºç«¯å£ï¼‰
DEFAULT_INSTANCE_IP = None  # è‡ªåŠ¨è·å–æœ¬æœºIP


def get_local_ip():
    """è‡ªåŠ¨è·å–æœ¬æœºå¯¹å¤–IPï¼ˆé€‚é…å¤šæœºéƒ¨ç½²ï¼Œæ— éœ€æ‰‹åŠ¨é…ç½®ï¼‰"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))  # è¿æ¥å…¬ç½‘DNSï¼Œä¸å‘é€æ•°æ®
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        return "127.0.0.1"  # å¼‚å¸¸æ—¶é»˜è®¤æœ¬åœ°IP


def parse_args():
    parser = argparse.ArgumentParser(description="stunnel-FIXç›‘æ§+Prometheus Exporterï¼ˆå¤šæœºé€‚é…ï¼‰")
    parser.add_argument("-d", "--downstreams", type=str, nargs="+", required=True, help="ä¸‹æ¸¸æœåŠ¡å™¨IP:ç«¯å£")
    parser.add_argument("-l", "--stunnel-listen", type=int, default=DEFAULT_STUNNEL_LISTEN_PORT, help="stunnelç›‘å¬ç«¯å£")
    parser.add_argument("-s", "--stunnel-log", type=str, default=DEFAULT_STUNNEL_LOG, help="stunnelæ—¥å¿—è·¯å¾„")
    parser.add_argument("-i", "--interval", type=int, default=DEFAULT_MONITOR_INTERVAL, help="æŒ‡æ ‡æ›´æ–°é—´éš”ï¼ˆç§’ï¼‰")
    parser.add_argument("-t", "--timeout", type=int, default=DEFAULT_TIMEOUT, help="è¿æ¥è¶…æ—¶ï¼ˆç§’ï¼‰")
    parser.add_argument("-p", "--exporter-port", type=int, default=DEFAULT_EXPORTER_PORT, help="Exporteræš´éœ²ç«¯å£")
    return parser.parse_args()


def validate_servers(servers_str):
    valid_servers = []
    for s in servers_str:
        if ":" not in s:
            print(f"âŒ æ— æ•ˆæœåŠ¡å™¨ï¼š{s}", file=sys.stderr)
            sys.exit(1)
        ip, port_str = s.split(":", 1)
        try:
            port = int(port_str)
            valid_servers.append((ip, port))
        except ValueError:
            print(f"âŒ æ— æ•ˆç«¯å£ï¼š{port_str}", file=sys.stderr)
            sys.exit(1)
    return valid_servers


def get_os_type():
    os_name = sys.platform.lower()
    return "linux" if os_name.startswith("linux") else "windows" if os_name.startswith("win") else None


def init_raw_socket(os_type):
    try:
        if os_type == "linux":
            sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))
        elif os_type == "windows":
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
        else:
            raise NotImplementedError(f"ä¸æ”¯æŒOSï¼š{os_type}")
        return sock
    except PermissionError:
        print("âŒ éœ€root/ç®¡ç†å‘˜æƒé™è¿è¡Œ", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"âŒ æŠ“åŒ…socketåˆå§‹åŒ–å¤±è´¥ï¼š{e}", file=sys.stderr)
        sys.exit(1)


def parse_tcp_packet(data):
    try:
        ip_header = data[:20]
        iph = struct.unpack('!BBHHHBBH4s4s', ip_header)
        if iph[6] != 6:
            return None
        src_ip = socket.inet_ntoa(iph[8])
        dst_ip = socket.inet_ntoa(iph[9])
        ip_header_len = (iph[0] & 0x0F) * 4
        tcp_header = data[ip_header_len:ip_header_len+20]
        tcph = struct.unpack('!HHLLBBHHH', tcp_header)
        src_port = tcph[0]
        dst_port = tcph[1]
        tcp_header_len = ((tcph[4] & 0xF0) >> 4) * 4
        tcp_data = data[ip_header_len + tcp_header_len:]
        return {'src': (src_ip, src_port), 'dst': (dst_ip, dst_port), 'data': tcp_data} if tcp_data else None
    except Exception:
        return None


def parse_fix_msg_type(tcp_data):
    fields = tcp_data.split(FIX_SOH)
    for field in fields:
        if field.startswith(FIX_MSGTYPE_TAG):
            msg_type = field[len(FIX_MSGTYPE_TAG):].decode('ascii', errors='ignore')
            return msg_type if msg_type in ['A', '5'] else None
    return None


def parse_stunnel_log(log_path, client_forward_map, forward_client_map):
    try:
        for line in fileinput.input(log_path, follow=True):
            line = line.strip()
            connect_match = STUNNEL_CONNECT_PATTERN.search(line)
            if connect_match:
                client_key = (connect_match.group('client_ip'), int(connect_match.group('client_port')))
                downstream = (connect_match.group('downstream_ip'), int(connect_match.group('downstream_port')))
                client_forward_map[client_key] = {
                    'downstream': downstream, 'forward_key': None, 'last_active': time.time()
                }
            close_match = STUNNEL_CLOSE_PATTERN.search(line)
            if close_match:
                client_key = (close_match.group('client_ip'), int(close_match.group('client_port')))
                if client_key in client_forward_map:
                    forward_key = client_forward_map[client_key]['forward_key']
                    if forward_key in forward_client_map:
                        del forward_client_map[forward_key]
                    del client_forward_map[client_key]
    except Exception as e:
        print(f"âš ï¸  æ—¥å¿—è§£æå¼‚å¸¸ï¼š{e}", file=sys.stderr)


def associate_forward_connection(tcp_info, client_forward_map, forward_client_map):
    forward_src = tcp_info['src']
    forward_dst = tcp_info['dst']
    forward_key = (f"{forward_src[0]}:{forward_src[1]}", f"{forward_dst[0]}:{forward_dst[1]}")
    for client_key, info in client_forward_map.items():
        if info['downstream'] == forward_dst and info['forward_key'] is None:
            info['forward_key'] = forward_key
            info['last_active'] = time.time()
            forward_client_map[forward_key] = client_key
            break
    return forward_key


def clean_timeout_connections(client_forward_map, forward_client_map, login_states, timeout):
    current_time = time.time()
    expired_clients = []
    for client_key, info in client_forward_map.items():
        if current_time - info['last_active'] > timeout:
            expired_clients.append(client_key)
    for client_key in expired_clients:
        forward_key = client_forward_map[client_key]['forward_key']
        if forward_key in forward_client_map:
            del forward_client_map[forward_key]
            if forward_key in login_states:
                del login_states[forward_key]
        del client_forward_map[client_key]


def update_metrics(client_forward_map, forward_client_map, login_states, instance_ip, stunnel_listen):
    """æ›´æ–°PrometheusæŒ‡æ ‡ï¼ˆæ ¸å¿ƒï¼šæ‰“ä¸ŠèŠ‚ç‚¹æ ‡ç­¾ï¼‰"""
    # åŸºç¡€æ ‡ç­¾ï¼ˆæ‰€æœ‰æŒ‡æ ‡å…±äº«ï¼‰
    base_labels = {
        "instance": instance_ip,
        "stunnel_listen": str(stunnel_listen)
    }
    # 1. æ´»è·ƒå®¢æˆ·ç«¯è¿æ¥æ•°
    metrics["fix_active_client_connections"][tuple(sorted(base_labels.items()))] = len(client_forward_map)
    # 2. æ´»è·ƒè½¬å‘è¿æ¥æ•°
    metrics["fix_forward_connections"][tuple(sorted(base_labels.items()))] = len(forward_client_map)
    # 3. å·²ç™»å½•è¿æ¥æ•°ï¼ˆæ±‡æ€»ï¼‰
    logged_in_count = sum(1 for k, v in login_states.items() if v and k in forward_client_map)
    metrics["fix_logged_in_connections"][tuple(sorted(base_labels.items()))] = logged_in_count
    # 4. å•ä¸ªå®¢æˆ·ç«¯ç™»å½•çŠ¶æ€ï¼ˆæ˜ç»†æŒ‡æ ‡ï¼‰
    # å…ˆæ¸…ç©ºæ—§æ˜ç»†ï¼Œé¿å…è¿‡æœŸæ•°æ®
    for key in list(metrics["fix_connection_status"].keys()):
        if key[0][1] == instance_ip:  # åªæ¸…ç©ºå½“å‰èŠ‚ç‚¹çš„æ˜ç»†
            del metrics["fix_connection_status"][key]
    # æ–°å¢å½“å‰æ˜ç»†
    for forward_key, is_logged in login_states.items():
        if forward_key in forward_client_map:
            client_key = forward_client_map[forward_key]
            downstream = client_forward_map[client_key]['downstream']
            detail_labels = {
                "instance": instance_ip,
                "client_ip": client_key[0],
                "client_port": str(client_key[1]),
                "downstream": f"{downstream[0]}:{downstream[1]}"
            }
            metrics["fix_connection_status"][tuple(sorted(detail_labels.items()))] = 1 if is_logged else 0


# ========== Prometheus Exporter HTTPæœåŠ¡ ==========
class MetricsHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == "/metrics":
            self.send_response(200)
            self.send_header("Content-Type", "text/plain; version=0.0.4")
            self.end_headers()
            # ç”ŸæˆPrometheusæ ¼å¼å“åº”
            response = []
            for metric_name, label_values in metrics.items():
                # æ·»åŠ æŒ‡æ ‡æ³¨é‡Š
                response.append(f"# HELP {metric_name} FIX connection monitor metric")
                response.append(f"# TYPE {metric_name} gauge")
                # æ·»åŠ æ¯ä¸ªæ ‡ç­¾ç»„åˆçš„æŒ‡æ ‡å€¼
                for labels_tuple, value in label_values.items():
                    labels_str = ",".join([f"{k}=\"{v}\"" for k, v in labels_tuple])
                    response.append(f"{metric_name}{{{labels_str}}} {value:.0f}")
                response.append("")  # ç©ºè¡Œåˆ†éš”æŒ‡æ ‡
            self.wfile.write("\n".join(response).encode("utf-8"))
        else:
            self.send_response(404)
            self.end_headers()


def start_exporter(port):
    """å¯åŠ¨Exporter HTTPæœåŠ¡ï¼ˆç‹¬ç«‹çº¿ç¨‹ï¼‰"""
    server = HTTPServer(("0.0.0.0", port), MetricsHandler)
    print(f"ğŸ“¡ Prometheus Exporterå¯åŠ¨ï¼šhttp://0.0.0.0:{port}/metrics")
    server.serve_forever()


# ========== ä¸»ç›‘æ§é€»è¾‘ ==========
def main():
    args = parse_args()
    downstream_servers = validate_servers(args.downstreams)
    downstream_set = set(downstream_servers)
    os_type = get_os_type()
    instance_ip = get_local_ip()  # è‡ªåŠ¨è·å–èŠ‚ç‚¹IPï¼ˆå¤šæœºæ ‡ç­¾ï¼‰
    print(f"âœ… èŠ‚ç‚¹IPï¼š{instance_ip} | stunnelç›‘å¬ï¼š{args.stunnel_listen} | ä¸‹æ¸¸ï¼š{downstream_servers}")

    # åˆå§‹åŒ–èµ„æº
    sock = init_raw_socket(os_type)
    client_forward_map = dict()
    forward_client_map = dict()
    login_states = defaultdict(bool)

    # å¯åŠ¨Exporterçº¿ç¨‹ï¼ˆç‹¬ç«‹è¿è¡Œï¼Œä¸é˜»å¡ç›‘æ§é€»è¾‘ï¼‰
    exporter_thread = threading.Thread(target=start_exporter, args=(args.exporter_port,), daemon=True)
    exporter_thread.start()

    # å¯åŠ¨stunnelæ—¥å¿—è§£æçº¿ç¨‹
    log_thread = threading.Thread(
        target=parse_stunnel_log, args=(args.stunnel_log, client_forward_map, forward_client_map), daemon=True
    )
    log_thread.start()

    last_metric_update = time.time()
    try:
        while True:
            current_time = time.time()
            try:
                # æŠ“åŒ…è§£æ
                data, _ = sock.recvfrom(4096)
                tcp_info = parse_tcp_packet(data)
                if not tcp_info or tcp_info['dst'] not in downstream_set:
                    continue
                forward_key = associate_forward_connection(tcp_info, client_forward_map, forward_client_map)
                if forward_key not in forward_client_map:
                    continue
                # æ›´æ–°è¿æ¥æ´»åŠ¨æ—¶é—´
                client_key = forward_client_map[forward_key]
                if client_key in client_forward_map:
                    client_forward_map[client_key]['last_active'] = current_time
                # è§£æFIXç™»å½•/ç™»å‡º
                fix_msg_type = parse_fix_msg_type(tcp_info['data'])
                if fix_msg_type == 'A':
                    login_states[forward_key] = True
                elif fix_msg_type == '5':
                    login_states[forward_key] = False
            except Exception:
                continue

            # å®šæ—¶æ›´æ–°æŒ‡æ ‡ï¼ˆä¸Exporteré…åˆï¼‰
            if current_time - last_metric_update >= args.interval:
                clean_timeout_connections(client_forward_map, forward_client_map, login_states, args.timeout)
                update_metrics(client_forward_map, forward_client_map, login_states, instance_ip, args.stunnel_listen)
                last_metric_update = current_time
    except KeyboardInterrupt:
        print("\nğŸ›‘ ç›‘æ§ä¸­æ–­ï¼Œæ¸…ç†èµ„æº...")
    finally:
        if os_type == "windows":
            sock.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)
        sock.close()
        print("âœ… ç¨‹åºé€€å‡º")


if __name__ == "__main__":
    main()



global:
  scrape_interval: 15s  # æ‹‰å–é—´éš”ï¼ˆâ‰¤è„šæœ¬æŒ‡æ ‡æ›´æ–°é—´éš”ï¼Œå»ºè®®15sï¼‰

scrape_configs:
  - job_name: "edmz_fix_monitor"  # ä»»åŠ¡åï¼ˆGrafanaä¸­ç­›é€‰ç”¨ï¼‰
    static_configs:
      # åˆ—å‡ºæ‰€æœ‰EDMZèŠ‚ç‚¹çš„IP:Exporterç«¯å£ï¼ˆé»˜è®¤9101ï¼‰
      - targets: ["10.0.0.10:9101", "10.0.0.11:9101", "10.0.0.12:9101"]  # æ›¿æ¢ä¸ºå®é™…èŠ‚ç‚¹IP



# Linux systemdç¤ºä¾‹ï¼ˆ/etc/systemd/system/fix-monitor.serviceï¼‰
[Unit]
Description=FIX Login Monitor with Prometheus Exporter
After=network.target stunnel.service

[Service]
User=root
WorkingDirectory=/opt/fix-monitor
ExecStart=/usr/bin/python /opt/fix-monitor/stunnel_fix_exporter.py -d 192.168.1.100:9876 -s /var/log/stunnel/stunnel.log
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target