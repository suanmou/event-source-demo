import os
import json
import jieba
import sqlglot
from openai import OpenAI
from dotenv import load_dotenv
from typing import List, Dict, Optional, Tuple
from pydantic import BaseModel

# 加载环境变量
load_dotenv()

# ------------------- 1. 结构化元数据模型（复用） -------------------
class FieldDict(BaseModel):
    field_name: str          # 字段物理名
    field_alias: str         # 字段业务别名
    field_type: str          # DuckDB字段类型
    field_desc: str          # 字段业务含义
    field_enum: List[str]    # 字段枚举值
    field_constraint: str    # 字段业务约束

class TableDict(BaseModel):
    table_name: str          # 表物理名
    table_alias: str         # 表业务别名
    table_desc: str          # 表业务含义
    table_relation: str      # 表关联关系
    fields: List[FieldDict]  # 字段字典列表

# ------------------- 2. 增强版工具类（新增Prompt自定义功能） -------------------
class OptimizedDuckDBText2SqlTool:
    def __init__(
        self,
        table_dicts: List[TableDict],
        duckdb_dialect: str = "duckdb",
        few_shot_examples: List[Dict] = None,
        llm_model: str = "gpt-3.5-turbo"
    ):
        self.table_dicts = table_dicts
        self.duckdb_dialect = duckdb_dialect
        self.few_shot_examples = few_shot_examples or self._default_few_shot()
        self.llm_model = llm_model
        self.llm_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

        # 构建字段/表名-别名双向索引
        self.field_name2alias = self._build_field_index()
        self.table_name2alias = self._build_table_index()

    def _build_field_index(self) -> Dict[str, str]:
        index = {}
        for table in self.table_dicts:
            for field in table.fields:
                index[field.field_name.lower()] = field.field_alias
                for alias in field.field_alias.split("|"):
                    index[alias.lower()] = field.field_name
        return index

    def _build_table_index(self) -> Dict[str, str]:
        index = {}
        for table in self.table_dicts:
            index[table.table_name.lower()] = table.table_alias
            for alias in table.table_alias.split("|"):
                index[alias.lower()] = table.table_name
        return index

    def _default_few_shot(self) -> List[Dict]:
        return [
            {
                "user_query": "查询2026年1月的手机销售额",
                "sql": "SELECT product_name, SUM(amount) AS total_sales FROM sales WHERE product_name = '手机' AND sale_date BETWEEN '2026-01-01' AND '2026-01-31' GROUP BY product_name",
                "explanation": "筛选product_name为手机，sale_date在2026年1月，对amount求和"
            },
            {
                "user_query": "统计每个产品的订单数",
                "sql": "SELECT product_name, COUNT(id) AS order_count FROM sales GROUP BY product_name",
                "explanation": "按product_name分组，对id计数得到订单数"
            }
        ]

    def _preprocess_user_query(self, user_query: str) -> str:
        """用户查询预处理：分词、别名替换、消歧、补全"""
        seg_list = jieba.lcut(user_query)
        processed_query = []
        for word in seg_list:
            if word.lower() in self.field_name2alias:
                processed_query.append(self.field_name2alias[word.lower()])
            elif word.lower() in self.table_name2alias:
                processed_query.append(self.table_name2alias[word.lower()])
            else:
                processed_query.append(word)
        processed_query_str = "".join(processed_query)

        # 补全年份、消歧（可根据业务扩展）
        if "1月" in processed_query_str and "年" not in processed_query_str:
            processed_query_str = processed_query_str.replace("1月", "2026年1月")
        if "销售额" in processed_query_str and "SUM" not in processed_query_str:
            processed_query_str += "（销售额指amount字段求和）"
        return processed_query_str

    # ========== 新增功能1：获取工具生成的默认增强版Prompt ==========
    def get_default_prompt(self, user_query: str) -> str:
        """
        获取工具为用户查询构造的默认增强版Prompt
        :param user_query: 原始用户自然语言查询
        :return: 结构化的增强版Prompt文本
        """
        processed_query = self._preprocess_user_query(user_query)
        return self._build_enhanced_prompt(processed_query)

    def _build_enhanced_prompt(self, processed_query: str) -> str:
        """构造增强版Prompt（内部方法，被get_default_prompt和原有流程调用）"""
        # 结构化表字典文本
        table_dict_text = "\n\n".join([
            f"""
            【表信息】
            物理表名：{table.table_name}
            业务表名：{table.table_alias}
            表含义：{table.table_desc}
            关联关系：{table.table_relation}
            字段列表：
            {chr(10).join([f'- {f.field_name}（{f.field_alias}）：{f.field_desc}，类型：{f.field_type}，枚举值：{f.field_enum}，约束：{f.field_constraint}' for f in table.fields])}
            """
            for table in self.table_dicts
        ])

        # Few-shot示例文本
        few_shot_text = "\n\n".join([
            f"""示例{i+1}：
            用户查询：{example['user_query']}
            生成SQL：{example['sql']}
            匹配逻辑：{example['explanation']}
            """
            for i, example in enumerate(self.few_shot_examples)
        ])

        # 最终Prompt模板
        prompt = f"""
        你是精通DuckDB SQL的业务专家，需根据以下规则生成精准匹配用户意图的只读SELECT语句：
        【核心规则】
        1. 语义匹配优先：必须严格对齐用户查询的业务意图，字段/表名优先使用物理名；
        2. 语法合规：仅生成{self.duckdb_dialect}方言兼容的SQL，禁止INSERT/UPDATE/DELETE/DROP等修改语句；
        3. 业务约束：必须遵守字段的业务约束（如金额>=0、日期格式YYYY-MM-DD）；
        4. 枚举值匹配：筛选字段时必须使用给定的枚举值；
        5. 只返回SQL语句，无任何额外解释、注释。

        【表字典信息】
        {table_dict_text}

        【匹配示例（参考逻辑）】
        {few_shot_text}

        【用户查询（已预处理）】
        {processed_query}

        【生成要求】
        生成的SQL必须100%匹配用户查询的业务意图，字段/表名准确，聚合/筛选逻辑正确：
        """
        return prompt.strip()

    # ========== 新增功能2：使用用户自定义的Prompt生成SQL ==========
    def generate_sql_with_custom_prompt(self, custom_prompt: str, max_retry: int = 2) -> Tuple[str, Optional[str]]:
        """
        使用用户编辑后的自定义Prompt生成SQL，保留校验-重试逻辑
        :param custom_prompt: 用户修改后的Prompt文本
        :param max_retry: 最大重试次数
        :return: (生成的SQL/None, 错误信息/None)
        """
        # 首次基于自定义Prompt生成SQL
        try:
            response = self.llm_client.chat.completions.create(
                model=self.llm_model,
                messages=[{"role": "user", "content": custom_prompt}],
                temperature=0.1,
                max_tokens=500
            )
            generated_sql = response.choices[0].message.content.strip()
        except Exception as e:
            return "", f"基于自定义Prompt生成SQL失败：{str(e)}"

        # 校验+重试（复用原有校验逻辑，需传入原始用户查询，这里从Prompt中提取）
        # 简化处理：若用户未修改查询部分，可从Prompt中提取；也可让用户额外传入原始查询
        # 此处为了兼容，假设用户查询在Prompt的【用户查询】部分
        import re
        user_query_match = re.search(r"【用户查询（已预处理）】\n(.*?)\n\n【生成要求】", custom_prompt, re.DOTALL)
        user_query = user_query_match.group(1).strip() if user_query_match else custom_prompt

        retry_count = 0
        while retry_count < max_retry:
            is_valid, error = self._validate_sql_match(generated_sql, user_query)
            if is_valid:
                return generated_sql, None
            # 基于错误信息生成重试Prompt
            retry_prompt = f"""
            你之前生成的SQL不符合要求，错误原因：{error}
            请根据以下自定义Prompt修正SQL，确保符合所有规则：
            {custom_prompt}
            修正要求：解决{error}的问题，仅返回SQL语句，无其他内容。
            """
            try:
                response = self.llm_client.chat.completions.create(
                    model=self.llm_model,
                    messages=[{"role": "user", "content": retry_prompt}],
                    temperature=0.0,
                    max_tokens=500
                )
                generated_sql = response.choices[0].message.content.strip()
            except Exception as e:
                return "", f"重试{retry_count+1}次失败：{str(e)}"
            retry_count += 1
        return "", f"多次重试失败，最后错误：{error}"

    # ========== 原有功能：自动生成SQL（无改动，兼容） ==========
    def _validate_sql_match(self, sql: str, user_query: str) -> Tuple[bool, Optional[str]]:
        """SQL匹配度+安全性校验（复用）"""
        # 1. DuckDB方言语法校验
        try:
            sqlglot.parse_one(sql, dialect=self.duckdb_dialect)
        except sqlglot.errors.ParseError as e:
            return False, f"SQL语法错误：{str(e)}"

        # 2. 表/字段存在性校验
        parsed = sqlglot.parse_one(sql, dialect=self.duckdb_dialect)
        used_tables = [t.name.lower() for t in parsed.find_all(sqlglot.exp.Table)]
        used_fields = [c.name.lower() for c in parsed.find_all(sqlglot.exp.Column) if c.name]
        valid_tables = [t.table_name.lower() for t in self.table_dicts]

        for table in used_tables:
            if table not in valid_tables:
                return False, f"使用不存在的表：{table}"
        for table in self.table_dicts:
            if table.table_name.lower() in used_tables:
                valid_fields = [f.field_name.lower() for f in table.fields]
                for field in used_fields:
                    if field not in valid_fields and field != "*":
                        return False, f"表{table.table_name}不存在字段：{field}"

        # 3. 语义匹配校验
        if ("求和" in user_query or "销售额" in user_query) and "SUM(" not in sql.upper():
            return False, "用户查询要求求和，SQL未使用SUM函数"
        if ("统计数量" in user_query or "订单数" in user_query) and "COUNT(" not in sql.upper():
            return False, "用户查询要求计数，SQL未使用COUNT函数"
        return True, None

    def generate_matched_sql(self, user_query: str, max_retry: int = 2) -> Tuple[str, Optional[str]]:
        """原有自动生成流程：预处理→生成Prompt→生成SQL→校验重试"""
        processed_query = self._preprocess_user_query(user_query)
        prompt = self._build_enhanced_prompt(processed_query)
        return self.generate_sql_with_custom_prompt(prompt, max_retry)

# ------------------- 3. 测试示例：展示自定义Prompt功能 -------------------
if __name__ == "__main__":
    # 1. 模拟下游提供的表字典
    sales_fields = [
        FieldDict(
            field_name="id", field_alias="订单ID", field_type="INTEGER",
            field_desc="订单唯一标识", field_enum=[], field_constraint="id>0"
        ),
        FieldDict(
            field_name="product_name", field_alias="产品名称|商品名称", field_type="VARCHAR",
            field_desc="销售产品名称", field_enum=["手机", "电脑", "平板"], field_constraint=""
        ),
        FieldDict(
            field_name="sale_date", field_alias="销售日期|下单日期", field_type="DATE",
            field_desc="订单成交日期", field_enum=[], field_constraint="日期格式YYYY-MM-DD"
        ),
        FieldDict(
            field_name="amount", field_alias="订单金额|销售额", field_type="FLOAT",
            field_desc="订单成交金额", field_enum=[], field_constraint="amount>=0"
        )
    ]
    sales_table = TableDict(
        table_name="sales", table_alias="销售订单表|订单表",
        table_desc="存储产品销售订单信息", table_relation="无关联表", fields=sales_fields
    )

    # 2. 初始化工具
    tool = OptimizedDuckDBText2SqlTool(table_dicts=[sales_table])

    # 3. 场景1：获取默认Prompt并让用户编辑
    user_query = "查询1月手机的销售额总和"
    default_prompt = tool.get_default_prompt(user_query)
    print("===== 工具生成的默认Prompt =====")
    print(default_prompt)
    print("\n===== 请编辑上述Prompt后使用 =====")

    # 4. 场景2：用户修改Prompt后传入（示例：新增排序要求）
    custom_prompt = default_prompt + "\n额外要求：生成的SQL需要按total_sales降序排序"
    sql, error = tool.generate_sql_with_custom_prompt(custom_prompt)
    if error:
        print(f"生成失败：{error}")
    else:
        print(f"\n===== 基于自定义Prompt生成的SQL =====")
        print(sql)

    # 5. 场景3：使用原有自动流程（对比测试）
    auto_sql, auto_error = tool.generate_matched_sql(user_query)
    if not auto_error:
        print(f"\n===== 自动流程生成的SQL =====")
        print(auto_sql)